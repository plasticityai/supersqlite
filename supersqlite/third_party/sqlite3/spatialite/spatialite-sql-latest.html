<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<title>SpatiaLite SQL functions reference list</title>
		<style type="text/css">
			h2 {color:navy; text-align:center;} 
			h3 {color:blue;} 
			b {color:brown;}
			i {color:navy;}
		</style>
	</head><body bgcolor="#fffff0">
		<h2>SpatiaLite 4.3.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQL functions reference list</h2>
		<a href="https://www.gaia-gis.it/fossil/libspatialite">back</a>
		<ul>
			<li><a href="#version">SQL Version Info [and build options testing] functions</a></li>
			<li><a href="#generic">Generic SQL utility functions</a></li>
			<li><a href="#global">Global settings per connection</a></li>
			<li><a href="#math">SQL math functions</a></li>
			<li><a href="#error">SQL functions reporting GEOS / LWGEOM errors and warnings</a></li>
			<li><a href="#length_cvt">SQL length/distance unit-conversion functions</a></li>
			<li><a href="#dms_cvt">SQL conversion functions from DD/DMS notations (longitude/latitude)</a></li>
			<li><a href="#blob">SQL utility functions for BLOB objects</a></li>
			<li><a href="#p0">SQL utility functions [non-standard] for geometric objects</a></li>
			<li><a href="#p1">SQL functions for constructing a geometric object given its Well-known Text Representation</a></li>
			<li><a href="#p2">SQL functions for constructing a geometric object given its Well-known Binary Representation</a></li>
			<li><a href="#p3">SQL functions for obtaining the Well-known Text / Well-known Binary Representation of a geometric object</a></li>
			<li><a href="#p3misc">SQL functions supporting exotic geometric formats</a></li>
			<li><a href="#p4">SQL functions on type Geometry</a></li>
			<li><a href="#repair">SQL functions attempting to repair malformed Geometries</a></li>
			<li><a href="#compress">SQL Geometry-compression functions</a></li>
			<li><a href="#cast">SQL Geometry-type casting functions</a></li>
			<li><a href="#dims-cast">SQL Space-dimensions casting functions</a></li>
			<li><a href="#p5">SQL functions on type Point</a></li>
			<li><a href="#p6">SQL functions on type Curve [Linestring or Ring]</a></li>
			<li><a href="#p7">SQL functions on type LineString</a></li>
			<li><a href="#p8">SQL functions on type Surface [Polygon or Ring]</a></li>
			<li><a href="#p9">SQL functions on type Polygon</a></li>
			<li><a href="#p10">SQL functions on type GeomCollection</a></li>
			<li><a href="#p11">SQL functions that test approximate spatial relationships via MBRs</a></li>
			<li><a href="#p12">SQL functions that test spatial relationships</a></li>
			<li><a href="#p13">SQL functions for distance relationships</a></li>
			<li><a href="#p14">SQL functions that implement spatial operators</a></li>
			<li><a href="#p14b">SQL functions that implement spatial operators [GEOS specific features]</a></li>
			<li><a href="#p14c">SQL functions that implement spatial operators [GEOS advanced features]</a></li>
			<li><a href="#p14d">SQL functions that implement spatial operators [LWGEOM features]</a></li>
			<li><a href="#p15">SQL functions for coordinate transformations</a></li>
			<li><a href="#p15plus">SQL functions supporting Affine Transformations and Ground Control Points</a></li>
			<li><a href="#p16">SQL functions for Spatial-MetaData and Spatial-Index handling</a></li>
			<li><a href="#p16metacatalog">SQL functions supporting the MetaCatalog and related Statistics</a></li>
			<li><a href="#p16style">SQL functions supporting SLD/SE Styled Layers</a></li>
			<li><a href="#p16isometa">SQL functions supporting ISO Metadata</a></li>
			<li><a href="#p16fdo">SQL functions implementing FDO/OGR compatibility</a></li>
			<li><a href="#p16gpkg">SQL functions implementing OGC GeoPackage compatibility</a></li>
			<li><a href="#p17">SQL functions for MbrCache-based queries</a></li>
			<li><a href="#p18">SQL functions for R*Tree-based queries (Geometry Callbacks)</a></li>
			<li><a href="#xmlBlob">SQL functions supporting XmlBLOB</a></li>
			<li><a href="#srid">SQL functions supporting SRID inspection</a></li>
			<li><a href="#advanced">miscellaneous advanced SQL functions</a></li>
		</ul>
		<table bgcolor="#e2eae2" border="1" cellpadding="2" cellspacing="2" width="100%">
			<tbody><tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="version">SQL Version Info [and build options testing] functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>spatialite_version</b></td>
				<td>spatialite_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>SpatiaLite</b> version as a text string</td></tr>
			<tr><td><b>spatialite_target_cpu</b></td>
				<td>spatialite_target_cpu( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>SpatiaLite</b> Target CPU as a text string</td></tr>
			<tr><td><b>freexl_version</b></td>
				<td>freexl_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>FreeXL</b> version as a text string<br>
					or NULL if FreeXL is currently unsupported</td></tr>
			<tr><td><b>proj4_version</b></td>
				<td>proj4_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>PROJ.4</b> version as a text string<br>
					or NULL if PROJ.4 is currently unsupported</td></tr>
			<tr><td><b>geos_version</b></td>
				<td>geos_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>GEOS</b> version as a text string<br>
					or NULL if GEOS is currently unsupported</td></tr>
			<tr><td><b>lwgeom_version</b></td>
				<td>lwgeom_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>LWGEOM</b> version as a text string<br>
					or NULL if LWGEOM is currently unsupported</td></tr>
			<tr><td><b>libxml2_version</b></td>
				<td>libxml2_version( void ) : <i>String</i></td>
				<td colspan="3">returns the current <b>LibXML2</b> version as a text string<br>
					or NULL if LibXML2 is currently unsupported</td></tr>
			<tr><td><b>HasIconv</b></td>
				<td>HasIconv( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>ICONV</b></td></tr>
			<tr><td><b>HasMathSQL</b></td>
				<td>HasMathSQL( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>MATHSQL</b></td></tr>
			<tr><td><b>HasGeoCallbacks</b></td>
				<td>HasGeoCallbacks( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>GEOCALLBACKS</b></td></tr>
			<tr><td><b>HasProj</b></td>
				<td>HasProj( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>PROJ</b></td></tr>
			<tr><td><b>HasGeos</b></td>
				<td>HasGeos( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>GEOS</b></td></tr>
			<tr><td><b>HasGeosAdvanced</b></td>
				<td>HasGeosAdvanced( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>GEOSADVANCED</b></td></tr>
			<tr><td><b>HasGeosTrunk</b></td>
				<td>HasGeosTrunk( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>GEOSTRUNK</b></td></tr>
			<tr><td><b>HasLwGeom</b></td>
				<td>HasLwGeom( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>LWGEOM</b></td></tr>
			<tr><td><b>HasLibXML2</b></td>
				<td>HasLibXML2( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>LibXML2</b></td></tr>
			<tr><td><b>HasEpsg</b></td>
				<td>HasEpsg( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>EPSG</b></td></tr>
			<tr><td><b>HasFreeXL</b></td>
				<td>HasFreeXL( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>FREEXL</b></td></tr>
			<tr><td><b>HasGeoPackage</b></td>
				<td>HasGeoPackage( void ) : <i>Boolean</i></td>
				<td colspan="3">TRUE if the underlaying library was built enabling <b>GeoPackage</b> support (<b>GPKG</b>)</b>)</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="generic">Generic SQL functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CastToInteger</b></td>
				<td>CastToInteger( value <i>Generic</i> ) : <i>Integer</i></td>
				<td colspan="3">returns the intput value possibly casted to the Integer data-type: NULL if no conversion is possible.</td></tr>
			<tr><td><b>CastToDouble</b></td>
				<td>CastToDouble( value <i>Generic</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the intput value possibly casted to the Double data-type: NULL if no conversion is possible.</td></tr>
			<tr><td><b>CastToText</b></td>
				<td>CastToText( value <i>Generic</i> ) : <i>Text</i><hr>
				CastToText( value <i>Generic</i> , zero_pad <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">returns the intput value possibly casted to the Text data-type: NULL if no conversion is possible.<br>
				If an optional argument <b>zero_pad</b> is passed and the input value is of the Integer or Double type, then the returned string will be padded using as much trailing ZEROs so to ensure the required length.</td></tr>
			<tr><td><b>CastToBlob</b></td>
				<td>CastToBlob( value <i>Generic</i> ) : <i>Blob</i><hr>
                                CastToBlob( value <i>Generic</i> , hex_input <i>Boolean</i> ) : <i>Blob</i></td>
				<td colspan="3">returns the intput value possibly casted to the BLOB data-type:
                                if the optional argument <b>hex_input</b> is set to <b>TRUE</b> the input value will be expected to correspond to an HexaDecimal string, e.g. <b>01ab89EF</b>; if this assumption fails then NULL will be returned.<hr>
                                NULL if no conversion is possible.</td></tr>
			<tr><td><b>ForceAsNull</b></td>
				<td>ForceAsNull( val1 <i>Generic</i> , val2 <i>Generic</i>) : <i>Generic</i></td>
				<td colspan="3">if <b>val1</b> and <b>val2</b> are equal (and exactly of the same data-type) NULL will be returned; 
				otherwise <b>val1</b> will be returned absolutely untouched and still preserving its originale data-type.</td></tr>
			<tr><td><b>CreateUUID</b></td>
				<td>CreateUUID( void ) : <i>Text</i></td>
				<td colspan="3">returns a Version 4 (random) UUID (<a href="http://en.wikipedia.org/wiki/Universally_unique_identifier">Universally unique identifier</a>).</td></tr>
			<tr><td><b>MD5Checksum</b></td>
				<td>MD5Checksum( BLOB | TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the <a href="http://en.wikipedia.org/wiki/MD5">MD5 checksum</a> corresponding to the input value.<br>Will return <b>NULL</b> for non-BLOB or non-TEXT input.</td></tr>
			<tr><td><b>MD5TotalChecksum</b></td>
				<td>MD5TotalChecksum( BLOB | TEXT ) : <i>Text</i></td>
				<td colspan="3">returns a cumulative MD5 checksum.<br><b><u>aggregate function</u></b></td></tr>
			<tr><td><b>EncodeURL</b></td>
				<td>EncodeURL( TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the <a href="http://en.wikipedia.org/wiki/Percent-encoding">percent encoded URL</a> corresponding to the input value.<br>Will return <b>NULL</b> for invalid input.</td></tr>
			<tr><td><b>DecodeURL</b></td>
				<td>DecodeURL( TEXT ) : <i>Text</i></td>
				<td colspan="3">returns a plain URL from its corresponding percent encoding.<br>Will return <b>NULL</b> for invalid input.</td></tr>
			<tr><td><b>DirNameFromPath</b></td>
				<td>DirNameFromPath( TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the Directory Name from a relative or absolute Pathname.<br>Will return <b>NULL</b> for invalid input of for any simple path lacking a Directory.</td></tr>
			<tr><td><b>FullFileNameFromPath</b></td>
				<td>FullFileNameFromPath( TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the Full File Name (including an eventual File Extension) from a relative or absolute Pathname.<br>Will return <b>NULL</b> for invalid input of for any path
				 lacking a File Name.</td></tr>
			<tr><td><b>FileNameFromPath</b></td>
				<td>FileNameFromPath( TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the File Name (excluding an eventual File Extension) from a relative or absolute Pathname.<br>Will return <b>NULL</b> for invalid input of for any path
				 lacking a File Name.</td></tr>
			<tr><td><b>FileExtFromPath</b></td>
				<td>FileExtFromPath( TEXT ) : <i>Text</i></td>
				<td colspan="3">returns the File Extension from a relative or absolute Pathname.<br>Will return <b>NULL</b> for invalid input of for any path
				 lacking a File Name or when no Extension is present.</td></tr>
			<tr><td><b>eval</b></td>
				<td>eval( X <i>TEXT</i> [ , Y <i>TEXT</i> ) : <i>Text</i></td>
				<td colspan="3">Evaluate the SQL text in <b>X</b>.  Return the results, using string <b>Y</b> as the separator.<br>
				If <b>Y</b> is omitted, use a single space character.<hr>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
            <tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="global">Global settings per connection</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>EnableGpkgMode</b></td>
				<td>EnableGpkgMode( <i>void</i> ) : <i>void</i></td>
				<td colspan="3">Enables the <b>Geopackage mode</b><br>
				all connections initially start by disabling the GPKG mode, that has always to be explicitly enabled whenever reguired.<br>
				Enabling GPKG mode is a supported option only if the currently connected DB-file presents a GPKG layout.</td></tr>
			<tr><td><b>DisableGpkgMode</b></td>
				<td>DisableGpkgMode( <i>void</i> ) : <i>void</i></td>
				<td colspan="3">Disables the <b>Geopackage mode</b></td></tr>
			<tr><td><b>GetGpkgMode</b></td>
				<td>GetGpkgMode( <i>void</i> ) : <i>boolean</i></td>
				<td colspan="3">Returns <b>TRUE</b> if the <b>Geopackage mode</b> is currently enabled, otherwise <b>FALSE</b></td></tr>
			<tr><td><b>EnableGpkgAmphibiousMode</b></td>
				<td>EnableGpkgAmphibiousMode( <i>void</i> ) : <i>void</i></td>
				<td colspan="3">Enables the <b>Geopackage amphibious mode</b><br>
				all connections initially start by disabling the amphibious mode, that has always to be explicitly enabled whenever reguired.<br>
				<u>Note</u>: <i>GPKG mode</i> and <i>GPKG amphibious mode</i> are mutually exclusive options.</td></tr>
			<tr><td><b>DisableGpkgAmphibiousMode</b></td>
				<td>DisableGpkgAmphibiousMode( <i>void</i> ) : <i>void</i></td>
				<td colspan="3">Disables the <b>Geopackage amphibious mode</b></td></tr>
			<tr><td><b>GetGpkgAmphibiousMode</b></td>
				<td>GetGpkgAmphibiousMode( <i>void</i> ) : <i>boolean</i></td>
				<td colspan="3">Returns <b>TRUE</b> if the <b>Geopackage amphibious mode</b> is currently enabled, otherwise <b>FALSE</b></td></tr>
			<tr><td><b>SetDecimalPrecision</b></td>
				<td>SetDecimalPrecision( <i>integer</i> ) : <i>void</i></td>
				<td colspan="3">Explicitly sets the number of decimal digits (<i>precision</i>) to be displayed by <b>ST_AsText()</b> for coordinate values: the standard default setting is <b>6</b> decimal digits.<br>
				Passing any <b>negative</b> precision will automatically restore the initial default setting.<br>
				The <b>spatialite_gui</b> tool will honor this setting for all floating point values to be displayed on the screen.</td></tr>
			<tr><td><b>GetDecimalPrecision</b></td>
				<td>GetDecimalPrecision( <i>void</i> ) : <i>integer</i></td>
				<td colspan="3">Returns the currently set <b>decimal precision</b>.<br>
				A <b>negative</b> precision identifies the default setting.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="math">SQL math functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Abs</b></td>
				<td>Abs( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the absolute value of <b>x</b></td></tr>
			<tr><td><b>Acos</b></td>
				<td>Acos( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the arc cosine of <b>x</b>, that is, the value whose cosine is <b>x</b><br>
				returns NULL if <b>x</b> is not in the range -1 to 1</td></tr>
			<tr><td><b>Asin</b></td>
				<td>Asin( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the arc sine of <b>x</b>, that is, the value whose sine is <b>x</b><br>
				returns NULL if <b>x</b> is not in the range -1 to 1</td></tr>
			<tr><td><b>Atan</b></td>
				<td>Atan( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the arc tangent of <b>x</b>, that is, the value whose tangent is <b>x</b></td></tr>
			<tr><td><b>Atan2</b></td>
				<td>Atan2( y <i>Double precision</i> , x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the principal value of the arc tangent of <b>y/x</b> in radians, using the signs of the two
				arguments to determine the quadrant of the result. The eturn value is in the range[<b>-pi</b>, <b>pi</b>].</td></tr>
			<tr><td><b>Ceil<br>Ceiling</b></td>
				<td>Ceil( x <i>Double precision</i> ) : <i>Double precision</i><hr>
				Ceiling( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the smallest integer value not less than <b>x</b></td></tr>
			<tr><td><b>Cos</b></td>
				<td>Cos( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the cosine of <b>x</b>, where <b>x</b> is given in <u>radians</u></td></tr>
			<tr><td><b>Cot</b></td>
				<td>Cot( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the cotangent of <b>x</b>, where <b>x</b> is given in <u>radians</u></td></tr>
			<tr><td><b>Degrees</b></td>
				<td>Degrees( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the argument <b>x</b>, converted from radians to degrees</td></tr>
			<tr><td><b>Exp</b></td>
				<td>Exp( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the value of <b><i>e</i></b> (the base of natural logarithms) raised to the power of <b>x</b><hr>
				the inverse of this function is <b>Log()</b> (using a single argument only) or <b>Ln()</b></td></tr>
			<tr><td><b>Floor</b></td>
				<td>Floor( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the largest integer value not greater than <b>x</b></td></tr>
			<tr><td><b>Ln</b><br><b>Log</b></td>
				<td>Ln( x <i>Double precision</i> ) : <i>Double precision</i><hr>
				Log( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the natural logarithm of <b>x</b>; that is, the base-<b><i>e</i></b> logarithm of <b>x</b><br>
				If <b>x</b> is less than or equal to 0, then NULL is returned</td></tr>
			<tr><td><b>Log</b></td>
				<td>Log( b <i>Double precision</i> , x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the logarithm of <b>x</b> to the base <b>b</b><br>
				If <b>x</b> is less than or equal to 0, or if <b>b</b> is less than or equal to 1, then NULL is returned<hr>
				<b>Log(b, x)</b>  is equivalent to <b>Log(x)</b> / <b>Log(b)</b></td></tr>
			<tr><td><b>Log2</b></td>
				<td>Log2( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the base-2 logarithm of <b>x</b><hr>
				<b>Log2(x)</b>  is equivalent to <b>Log(x)</b> / <b>Log(2)</b></td></tr>
			<tr><td><b>Log10</b></td>
				<td>Log10( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the base-10 logarithm of <b>x</b><hr>
				<b>Log10(x)</b>  is equivalent to <b>Log(x)</b> / <b>Log(10)</b></td></tr>
			<tr><td><b>PI</b></td>
				<td>PI( void ) : <i>Double precision</i></td>
				<td colspan="3">returns the value of <b>PI</b></td></tr>
			<tr><td><b>Pow</b><br><b>Power</b></td>
				<td>Pow( x <i>Double precision</i> , y <i>Double precision</i> ) : <i>Double precision</i><hr>
				Power( x <i>Double precision</i> , y <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the value of <b>x</b> raised to the power of <b>y</b></td></tr>
			<tr><td><b>Radians</b></td>
				<td>Radians( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the argument <b>x</b>, converted from degrees to radians</td></tr>
			<tr><td><b>Sign</b></td>
				<td>Sign( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the sign of the argument as -1, 0, or 1, 
				depending on whether <b>x</b> is negative, zero, or positive. </td></tr>
			<tr><td><b>Sin</b></td>
				<td>Sin( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the sine of <b>x</b>, where <b>x</b> is given in <u>radians</u></td></tr>
			<tr><td><b>Sqrt</b></td>
				<td>Sqrt( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the square root of a non-negative number <b>x</b></td></tr>
			<tr><td><b>Stddev_pop</b></td>
				<td>Stddev_pop( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the population standard deviation of the input values<br><b><u>aggregate function</u></b></td></tr>
			<tr><td><b>Stddev_samp</b></td>
				<td>Stddev_samp( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the sample standard deviation of the input values<br><b><u>aggregate function</u></b></td></tr>
			<tr><td><b>Tan</b></td>
				<td>Tan( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the tangent of <b>x</b>, where <b>x</b> is given in <u>radians</u></td></tr>
			<tr><td><b>Var_pop</b></td>
				<td>Var_pop( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the population variance of the input values (<i>square of the population standard deviation</i>)<br>
				<b><u>aggregate function</u></b></td></tr>
			<tr><td><b>Var_samp</b></td>
				<td>Var_samp( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3">returns the sample variance of the input values (<i>square of the sample standard deviation</i>)<br>
				<b><u>aggregate function</u></b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="error">SQL functions reporting GEOS / LWGEOM errors and warnings</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>GEOS_GetLastWarningMsg</b></td>
				<td>GEOS_GetLastWarningMsg( <i>void</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td colspan="2">Will return the most recent warning message returned by GEOS (if any).<hr>
				<b>NULL</b> will be returned if there is no pending GEOS warning.</td></tr>
			<tr><td><b>GEOS_GetLastErrorMsg</b></td>
				<td>GEOS_GetLastErrorMsg( <i>void</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td colspan="2">Will return the most recent error message returned by GEOS (if any).<hr>
				<b>NULL</b> will be returned if there is no pending GEOS error.</td></tr>
			<tr><td><b>GEOS_GetLastAuxErrorMsg</b></td>
				<td>GEOS_GetLastAuxErrorMsg( <i>void</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td colspan="2">Will return the most recent error message (auxiliary) returned by GEOS (if any).<hr>
				<b>NULL</b> will be returned if there is no pending GEOS (auxiliary) error.</td></tr>
			<tr><td><b>GEOS_GetCriticalPointFromMsg</b></td>
				<td>GEOS_GetCriticalPointFromMsg( <i>void</i> ) : <i>Point</i><hr>
				GEOS_GetCriticalPointFromMsg( SRID <i>Integer</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td colspan="2">Will (possibly) return a Point Geometry extracted from the latest error / warning
				message returned by GEOS.<hr>
				<b>NULL</b> will be returned if there is no pending GEOS message, or if the current GEOS message
				doesn't contain a critical Point.</td></tr>
			<tr><td><b>LWGEOM_GetLastWarningMsg</b></td>
				<td>LWGEOM_GetLastWarningMsg( <i>void</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td colspan="2">Will return the most recent warning message returned by LWGEOM (if any).<hr>
				<b>NULL</b> will be returned if there is no pending LWGEOM warning.</td></tr>
			<tr><td><b>LWGEOM_GetLastErrorMsg</b></td>
				<td>LWGEOM_GetLastErrorMsg( <i>void</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td colspan="2">Will return the most recent error message returned by LWGEOM (if any).<hr>
				<b>NULL</b> will be returned if there is no pending LWGEOM error.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="length_cvt">SQL length/distance unit-conversion functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Kilometer</b></td>
				<td>CvtToKm( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromKm( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>kilometers</b></td></tr>
			<tr><td><b>Decimeter</b></td>
				<td>CvtToDm( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromDm( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>decimeters</b></td></tr>
			<tr><td><b>Centimeter</b></td>
				<td>CvtToCm( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromCm( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>centimeters</b></td></tr>
			<tr><td><b>Millimeter</b></td>
				<td>CvtToMm( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromMm( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>millimeters</b></td></tr>
			<tr><td><b>International Nautical Mile</b></td>
				<td>CvtToKmi( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromKmi( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international nautical miles</b></td></tr>
			<tr><td><b>International Inch</b></td>
				<td>CvtToIn( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromIn( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international inches</b></td></tr>
			<tr><td><b>International Foot</b></td>
				<td>CvtToFt( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromFt( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international feet</b></td></tr>
			<tr><td><b>International Yard</b></td>
				<td>CvtToYd( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromYd( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international yards</b></td></tr>
			<tr><td><b>International Statute Mile</b></td>
				<td>CvtToMi( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromMi( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international statute miles</b></td></tr>
			<tr><td><b>International Fathom</b></td>
				<td>CvtToFath( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromFath( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international fathoms</b></td></tr>
			<tr><td><b>International Chain</b></td>
				<td>CvtToCh( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromCh( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international chains</b></td></tr>
			<tr><td><b>International Link</b></td>
				<td>CvtToLink( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromLink( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>international links</b></td></tr>
			<tr><td><b>U.S. Inch</b></td>
				<td>CvtToUsIn( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromUsIn( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>U.S. inches</b></td></tr>
			<tr><td><b>U.S. Foot</b></td>
				<td>CvtToUsFt( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromUsFt( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>U.S. feet</b></td></tr>
			<tr><td><b>U.S. Yard</b></td>
				<td>CvtToUsYd( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromUsYd( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>U.S. yards</b></td></tr>
			<tr><td><b>U.S. Statute Mile</b></td>
				<td>CvtToUsMi( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromUsMi( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>U.S. statute miles</b></td></tr>
			<tr><td><b>U.S. Chain</b></td>
				<td>CvtToUsCh( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromUsCh( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>U.S. chains</b></td></tr>
			<tr><td><b>Indian Foot</b></td>
				<td>CvtToIndFt( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromIndFt( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>indian feet</b></td></tr>
			<tr><td><b>Indian Yard</b></td>
				<td>CvtToIndYd( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromIndYd( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>indian yards</b></td></tr>
			<tr><td><b>Indian Chain</b></td>
				<td>CvtToIndCh( x <i>Double precision</i> ) : <i>Double precision</i><hr>
					CvtFromIndCh( x <i>Double precision</i> ) : <i>Double precision</i></td>
				<td colspan="3"><b>meters</b> / <b>indian chains</b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="dms_cvt">SQL conversion functions from DD/DMS notations (longitude/latitude)</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>DD to DMS</b></td>
				<td>LongLatToDMS( longitude <i>Double precision</i> , latitude <i>Double precision</i> ) : <i>String</i></td>
				<td colspan="3">will return a DMS string (Degrees, Minutes and Seconds) starting from DD (Decimal Degrees) input coordinates<hr>
                                <b>NULL</b> will be returned on invalid input.</tr>
			<tr><td><b>DMS to DD</b></td>
				<td>LongitudeFromDMS( dms_expression <i>Sting</i> ) : <i>Double precision</i><hr>
                                    LatitudeFromDMS( dms_expression <i>Sting</i> ) : <i>Double precision</i></td>
				<td colspan="3">will return the DD coordinates from within a DMS expression<hr>
                                <b>NULL</b> will be returned on invalid input.</tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="blob">SQL utility functions for BLOB objects</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th colspan="3" bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>IsZipBlob</b></td>
				<td>IsZipBlob( content <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL or not-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid ZIP-compressed file</td></tr>
			<tr><td><b>IsPdfBlob</b></td>
				<td>IsPdfBlob( content <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL or not-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid PDF document</td></tr>
			<tr><td><b>IsGifBlob</b></td>
				<td>IsGifBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL or not-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid GIF image</td></tr>
			<tr><td><b>IsPngBlob</b></td>
				<td>IsPngBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL or not-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid PNG image</td></tr>
			<tr><td><b>IsTiffBlob</b></td>
				<td>IsTiffBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL or not-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid TIFF image</td></tr>
			<tr><td><b>IsJpegBlob</b></td>
				<td>IsJpegBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL or not-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid JPEG image</td></tr>
			<tr><td><b>IsExifBlob</b></td>
				<td>IsExifBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL or not-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid EXIF image<br>
					<u>Please note:</u> any valid EXIF image is a valid JPEG as well</td></tr>
			<tr><td><b>IsExifGpsBlob</b></td>
				<td>IsExifGpsBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL or not-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid EXIF-GPS image<br>
					<u>Please note:</u> any valid EXIF-GPS image is a valid EXIF and JPEG as well</td></tr>
			<tr><td><b>IsWebpBlob</b></td>
				<td>IsWebpBlob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL or not-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid WebP image</td></tr>
			<tr><td><b>IsJP2Blob</b></td>
				<td>IsJP2Blob( image <i>BLOB</i> ) : <i>Integer</i></td>
				<td colspan="3">The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL or not-BLOB argument.<hr>
					TRUE if this BLOB object corresponds to a valid JP2 [Jpeg2000] image</td></tr>
			<tr><td><b>GetMimeType</b></td>
				<td>GetMimeType( payload <i>BLOB</i> ) : <i>String</i></td>
				<td colspan="3">The return type is Text, and could be one of: <b>image/gif</b>, <b>image/png</b>,
					<b>image/jpeg</b>, <b>image/jp2</b>, </b></v><b>image/tiff</b>, <b>image/svg+xml</b>, <b>application/xml</b>,
					<b>application/zip</b>,	<b>application/pdf</b>.<br>
					NULL could be returned for an invalid argument or if no valid mime-type is detected.</td></tr>
			<tr><td><b>BlobFromFile</b></td>
				<td>BlobFromFile( filepath <i>String</i> ) : <i>BLOB</i></td>
				<td colspan="3">If <i>filepath</i> corresponds to some valid pathname, and the corresponding file
					can be actually accessed in read mode, then the whole file content will be returned as a
					BLOB value.<br>
					Otherwise NULL will be returned.<br>
					<u>Please note:</u> SQLite doesn't support BLOB values bigger than SQLITE_MAX_LENGTH (usually, 1 GB).<hr>
                                        <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                                        Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>BlobToFile</b></td>
				<td>BlobToFile( payload <i>BLOB</i> , filepath <i>String</i> ) : <i>Integer</i></td>
				<td colspan="3">If <i>payload</i> is of the BLOB-type, and if <i>filepath</i> corresponds to some valid pathname 
					(accessible in write/create mode), then the corresponding file will be created/overwritten so to
					contain the <i>payload</i>.<br>
					The return type is Integer, with a return value of 1 for success, 0 for failure.<hr>
                                        <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                                        Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>CountUnsafeTriggers</b></td>
				<td>CountUnsafeTriggers( ) : <i>Integer</i></td>
				<td colspan="3">This SQL function checks if the currently connected DB does contain any potentially malicious Trigger;
					carefully checking this conditions is a minimal precaution expected to be always verified before eventually activating the <b>SPATIALITE_SECURITY=relaxed</b> mode.<hr>
					The return type is Integer (total count of suspected Triggers); 0 means that the currently connected DB should be considered absolutely safe.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p0">SQL utility functions [<i>non-standard</i>] for geometric objects</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>GeomFromExifGpsBlob</b></td>
				<td>GeomFromExifGpsBlob( image <i>BLOB</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a POINT Geometry will be returned representing the GPS long/lat contained within EXIF-GPS <i>metadata</i>
				for the BLOB image<hr>
				NULL will be returned if for any reason it's not possible to build such a POINT</td></tr>
			<tr><td><b>ST_Point</b></td>
				<td>ST_Point( x <i>Double precision</i> , y <i>Double precision</i>  ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>simply an alias-name for <b>MakePoint()</b><br>
				<u>Please note</u>: the <u>SRID</u> argument is never supported by <u>ST_Point()</u></td></tr>
			<tr><td><b>MakePoint</b></td>
				<td>MakePoint( x <i>Double precision</i> , y <i>Double precision</i> ,
				[ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry will be returned representing the POINT defined by [<b>x y</b>] coordinates</td></tr>
			<tr><td><b>MakePointZ</b></td>
				<td>MakePointZ( x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> ,
				[ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry will be returned representing the POINT Z defined by [<b>x y z</b>] coordinates</td></tr>
			<tr><td><b>MakePointM</b></td>
				<td>MakePointM( x <i>Double precision</i> , y <i>Double precision</i> , m <i>Double precision</i> ,
				[ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry will be returned representing the POINT M defined by [<b>x y m</b>] coordinates</td></tr>
			<tr><td><b>MakePointZM</b></td>
				<td>MakePointZM( x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> ,
				m <i>Double precision</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry will be returned representing the POINT ZM defined by [<b>x y z m</b>] coordinates</td></tr>
			<tr><td><b>MakeLine</b></td>
				<td>MakeLine( pt1 <i>PointGeometry</i> , pt2 <i>PointGeometry</i> ) : <i>LinestringGeometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Linestring Geometry will be returned representing the segment connecting <b>pt1</b> to <b>pt2</b><hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>MakeLine</b></td>
				<td>MakeLine( geom <i>PointGeometry</i> ) : <i>LinestringGeometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Linestring Geometry will be returned connecting all the input Points (accordingly to input sequence)<br>
				<b><u>aggregate function</u></b><hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>MakeLine</b></td>
				<td>MakeLine( geom <i>MultiPointGeometry</i> , direction <i>Boolean</i> ) : <i>LinestringGeometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Linestring Geometry will be returned connecting all the input Points (accordingly to input sequence); <b>direction=FALSE</b> implies <u>reverse order</u>.<br>
				<u>Please note</u>: similar to the previuous one, but this one is an ordinary (not aggregate) function; a MultiPoint input is always expected.<hr>
				NULL will be returned if any error is encountered</td></tr>
                        <tr><td><b>MakeCircle</b></td>
				<td>MakeCircle( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				radius <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a closed LINESTRING approximating the Circle defined by <b>cx, cy</b> and <b>radius</b>.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the circumference; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeEllipse</b></td>
				<td>MakeEllipse( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				x_axis <i>Double precision</i> , y_axis <i>Double precisin</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a closed LINESTRING approximating the Ellipse defined by <b>cx, cy</b> and <b>x_axis, y_axis</b>.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the ellipse; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeArc</b></td>
				<td>MakeArc( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				radius <i>Double precision</i> , 
                                start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a LINESTRING approximating the Circular Arc defined by <b>cx, cy</b> and <b>radius</b>; the arc's extremities will be defined by <b>start, stop</b> angles expressed in degrees.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the circumference; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeEllipticArc</b></td>
				<td>MakeEllipticArc( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				x_axis <i>Double precision</i> , y_axis <i>Double precision</i> , 
                                start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a LINESTRING approximating the Elliptic Arc defined by <b>cx, cy</b> and <b>x_axis, y_axis</b>; the arc's extremities will be defined by <b>start, stop</b> angles expressed in degrees.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the ellipse; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeCircularSector</b></td>
				<td>MakeCircularSector( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				radius <i>Double precision</i> , 
                                start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a POLYGON approximating the Circular Sector defined by <b>cx, cy</b> and <b>radius</b>; the arc's extremities will be defined by <b>start, stop</b> angles expressed in degrees.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the circumference; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeEllipticSector</b></td>
				<td>MakeEllipticSector( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				x_axis <i>Double precision</i> , y_axis <i>Double precision</i> , 
                                start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a POLYGON approximating the Elliptic Sector defined by <b>cx, cy</b> and <b>x_axis, y_axis</b>; the arc's extremities will be defined by <b>start, stop</b> angles expressed in degrees.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the ellipse; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
                        <tr><td><b>MakeCircularStripe</b></td>
				<td>MakeCircularStripe( cx <i>Double precision</i> , cy <i>Double precision</i> ,
				radius_1 <i>Double precision</i> , radius_2 <i>Double precision</i> , 
                                start <i>Double precision</i> , stop <i>Double precision</i> [ , SRID <i>Integer</i> [ , 
                                step <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>will return a POLYGON approximating the Circular Stripe delimited by two arcs sharing the same Centre [<b>cx</b>, <b>cy</b>]
                                but having different radii [<b>radius_1</b>, <b>radius_2</b>]; the arc's extremities will be defined by <b>start, stop</b> angles expressed in degrees.<br>
                                The optional argument <b>step</b> if specified defines how many points will be interpolated on the circumference; a point will be set every <b>step</b> degrees.<br>
                                The implicit default setting corresponds to a point every <u>10</u> degrees.</td></tr>
			<tr><td><b>SquareGrid</b></td>
				<td>SquareGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , edges_only <i>Boolean</i> , [ origing <i>PointGeometry</i> ] ] ) : <i>Geometry</i><hr>
                                    ST_SquareGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , edges_only <i>Boolean</i> , [ origing <i>PointGeometry</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a grid of square cells (having the edge length of <i>size</i>) precisely covering the input Geometry.<br>
                                The returned Geometry will usually be of the <b>MultiPolygon</b> type (a collection of Squares), but will be a <b>MultiLinestring</b> if the optional <b>edges_only</b> argument is set to <b>TRUE</b><br>
                                If the optional <b>origin</b> argument (expected to be a Point) is not specified then the (0,0) grid origin will be assumed by default.<hr>
				NULL will be returned if any error is encountered.</td></tr>
			<tr><td><b>TriangularGrid</b></td>
				<td>TriangularGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , edges_only <i>Boolean</i> , [ origing <i>PointGeometry</i> ] ] ) : <i>Geometry</i><hr>
                                    ST_TriangularGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , edges_only <i>Boolean</i> , [ origing <i>PointGeometry</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a grid of triangular cells (having the edge length of <i>size</i>) precisely covering the input Geometry.<br>
                                The returned Geometry will usually be of the <b>MultiPolygon</b> type (a collection of Squares), but will be a <b>MultiLinestring</b> if the optional <b>edges_only</b> argument is set to <b>TRUE</b><br>
                                If the optional <b>origin</b> argument (expected to be a Point) is not specified then the (0,0) grid origin will be assumed by default.<hr>
				NULL will be returned if any error is encountered.</td></tr>
			<tr><td><b>HexagonalGrid</b></td>
				<td>HexagonalGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , edges_only <i>Boolean</i> , [ origing <i>PointGeometry</i> ] ] ) : <i>Geometry</i><hr>
                                    ST_HexagonalGrid( geom <i>ArealGeometry</i> , size <i>Double precision</i> [ , edges_only <i>Boolean</i> , [ origing <i>PointGeometry</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a grid of hexagonal cells (having the edge length of <i>size</i>) precisely covering the input Geometry.<br>
                                The returned Geometry will usually be of the <b>MultiPolygon</b> type (a collection of Squares), but will be a <b>MultiLinestring</b> if the optional <b>edges_only</b> argument is set to <b>TRUE</b><br>
                                If the optional <b>origin</b> argument (expected to be a Point) is not specified then the (0,0) grid origin will be assumed by default.<hr>
				NULL will be returned if any error is encountered.</td></tr>
			<tr><td><b>BuildMbr</b></td>
				<td>BuildMbr( x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>[<b>x1 y1</b>] and [<b>x2 y2</b>] are assumed to be Points identifying a line segment;
then a Geometry will be returned representing the MBR for this line segment</td></tr>
			<tr><td><b>BuildCircleMbr</b></td>
				<td>BuildCircleMbr( x <i>Double precision</i> , y <i>Double precision</i> ,
				radius <i>Double precision</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>[<b>x y</b>] is assumed to be the center of a circle of given <b>radius</b>;
then a Geometry will be returned representing the MBR for this circle</td></tr>
			<tr><td><b>Extent</b></td>
				<td>Extent( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object representing the bounding box that encloses a set of input values<br>
				<b><u>aggregate function</u></b></td></tr>
			<tr><td><b>ToGARS</b></td>
				<td>ToGARS( geom <i>Geometry</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td><b>geom</b> is expected to represent a POINT (longitude and latitude coordinates);
                                the corresponding <a href="https://www.gaia-gis.it/fossil/libspatialite/wiki?name=GARS">GARS</a> area designation code will be returned.<hr>
                                NULL will be returned if any error is encountered.</td></tr>
			<tr><td><b>GARSMbr</b></td>
				<td>GARSMbr( code <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td><b>code</b> is assumed to represent a valid GARS area designation code;
a Geometry will be returned representing the MBR for the corresponding GARS area.<hr>
                                NULL will be returned if any error is encountered.</td></tr>
			<tr><td><b>MbrMinX</b></td>
				<td>MbrMinX( geom <i>Geometry</i>) : <i>Double precision</i><hr>
				    ST_MinX( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the x-coordinate for <i>geom</i> MBR's <u>leftmost side</u> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry.</td></tr>
			<tr><td><b>MbrMinY</b></td>
				<td>MbrMinY( geom <i>Geometry</i>) : <i>Double precision</i><hr>
				    ST_MinY( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the y-coordinate for <i>geom</i> MBR's <u>lowermost side</u> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry.</td></tr>
			<tr><td><b>MbrMaxX</b></td>
				<td>MbrMaxX( geom <i>Geometry</i>) : <i>Double precision</i><hr>
				    ST_MaxX( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the x-coordinate for <i>geom</i> MBR's <u>rightmost side</u> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry.</td></tr>
			<tr><td><b>MbrMaxY</b></td>
				<td>MbrMaxY( geom <i>Geometry</i>) : <i>Double precision</i><hr>
				    ST_MaxY( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the y-coordinate for <i>geom</i> MBR's <u>uppermost side</u> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry.</td></tr>
			<tr><td><b>MinZ</b></td>
				<td>ST_MinZ( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the minimum Z-coordinate value for <i>geom</i> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry or if <i>geom</i> has no Z dimension.</td></tr>
			<tr><td><b>MaxZ</b></td>
				<td>ST_MaxZ( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the maximum Z-coordinate value for <i>geom</i> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry or if <i>geom</i> has no Z dimension.</td></tr>
			<tr><td><b>MinM</b></td>
				<td>ST_MinM( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the minimum M-coordinate value for <i>geom</i> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry or if <i>geom</i> has no M dimension.</td></tr>
			<tr><td><b>MaxM</b></td>
				<td>ST_MaxM( geom <i>Geometry</i>) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the maximum M-coordinate value for <i>geom</i> as a double precision number.<hr>
                                NULL will be returned if <i>geom</i> isn't a valid Geometry or if <i>geom</i> has no M dimension.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p1">SQL functions for constructing a geometric object given its Well-known Text Representation</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>GeomFromText</b></td>
				<td>GeomFromText( wkt <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i><hr>
					ST_GeomFromText( wkt <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its Well-known text Representation</td></tr>
			<tr><td><b>ST_WKTToSQL</b></td>
				<td>ST_WKTToSQL( wkt <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td><b>SQL/MM</b> compliant: simply an <i>alias name</i> for <b>ST_GeomFromText</b><hr>
                                        <u>Please note</u>: <b>SRID=0</b> is always assumed.</td></tr>
			<tr><td><b>PointFromText</b></td>
				<td>PointFromText( wktPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Point</i><hr>
					ST_PointFromText( wktPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Point</td></tr>
			<tr><td><b>LineFromText</b><br><b>LineStringFromText</b></td>
				<td>LineFromText( wktLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					ST_LineFromText( wktLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					LineStringFromText( wktLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					ST_LineStringFromText( wktLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Linestring</td></tr>
			<tr><td><b>PolyFromText</b><br><b>PolygonFromText</b></td>
				<td>PolyFromText( wktPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_PolyFromText( wktPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					PolygonFromText( wktPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_PolygonFromText( wktPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Polygon</td></tr>
			<tr><td><b>MPointFromText</b><br><b>MultiPointFromText</b></td>
				<td>MPointFromText( wktMultiPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i><hr>
					ST_MPointFromText( wktMultiPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i><hr>
					MultiPointFromText( wktMultiPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i><hr>
					ST_MultiPointFromText( wktMultiPoint <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiPoint</td></tr>
			<tr><td><b>MLineFromText</b><br><b>MultiLineStringFromText</b></td>
				<td>MLineFromText( wktMultiLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					ST_MLineFromText( wktMultiLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					MultiLineStringFromText( wktMultiLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					ST_MultiLineStringFromText( wktMultiLineString <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiLinestring</td></tr>
			<tr><td><b>MPolyFromText</b><br><b>MultiPolygonFromText</b></td>
				<td>MPolyFromText( wktMultiPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_MPolyFromText( wktMultiPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					MultiPolygonFromText( wktMultiPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_MultiPolygonFromText( wktMultiPolygon <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiPolygon</td></tr>
			<tr><td><b>GeomCollFromText</b><br><b>GeometryCollectionFromText</b></td>
				<td>GeomCollFromText( wktGeometryCollection <i>String</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					ST_GeomCollFromText( wktGeometryCollection <i>String</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					GeometryCollectionFromText( wktGeometryCollection <i>String</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					ST_GeometryCollectionFromText( wktGeometryCollection <i>String</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a GeometryCollection</td></tr>
			<tr><td><b>BdPolyFromText</b></td>
				<td>BdPolyFromText( wktMultilinestring <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_BdPolyFromText( wktMultilinestring <i>String</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Construct a Polygon given an arbitrary collection of closed linestrings as a MultiLineString text representation.
				<hr><i>see also</i>: <b>BuildArea()</b>, <b>Polygonize()</b></td></tr>
			<tr><td><b>BdMPolyFromText</b></td>
				<td>BdMPolyFromText( wktMultilinestring <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_BdMPolyFromText( wktMultilinestring <i>String</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Construct a MultiPolygon given an arbitrary collection of closed linestrings as a MultiLineString text representation.
				<hr><i>see also</i>: <b>BuildArea()</b>, <b>Polygonize()</b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p2">SQL functions for constructing a geometric object given its Well-known Binary Representation</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>GeomFromWKB</b></td>
				<td>GeomFromWKB( wkbGeometry <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i><hr>
					ST_GeomFromWKB( wkbGeometry <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its Well-known binary Representation</td></tr>
			<tr><td><b>ST_WKBToSQL</b></td>
				<td>ST_WKBToSQL( wkbGeometry <i>Binary</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td><b>SQL/MM</b> compliant: simply an <i>alias name</i> for <b>ST_GeomFromWKB</b><hr>
                                        <u>Please note</u>: <b>SRID=0</b> is always assumed.</td></tr>
			<tr><td><b>PointFromWKB</b></td>
				<td>PointFromWKB( wkbPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Point</i><hr>
					ST_PointFromWKB( wkbPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Point</td></tr>
			<tr><td><b>LineFromWKB</b><br><b>LineStringFromWKB</b></td>
				<td>LineFromWKB( wkbLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					ST_LineFromWKB( wkbLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					LineStringFromText( wkbLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i><hr>
					ST_LineStringFromText( wkbLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Linestring</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Linestring</td></tr>
			<tr><td><b>PolyFromWKB</b><br><b>PolygonFromWKB</b></td>
				<td>PolyFromWKB( wkbPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_PolyFromWKB( wkbPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					PolygonFromWKB( wkbPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_PolygonFromWKB( wkbPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a Polygon</td></tr>
			<tr><td><b>MPointFromWKB</b><br><b>MultiPointFromWKB</b></td>
				<td>MPointFromWKB( wkbMultiPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i><hr>
					ST_MPointFromWKB( wkbMultiPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i><hr>
					MultiPointFromWKB( wkbMultiPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i>
					ST_MultiPointFromWKB( wkbMultiPoint <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPoint</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiPoint</td></tr>
			<tr><td><b>MLineFromWKB</b><br><b>MultiLineStringFromWKB</b></td>
				<td>MLineFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					ST_MLineFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					MultiLineStringFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i><hr>
					ST_MultiLineStringFromWKB( wkbMultiLineString <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiLinestring</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiLinestring</td></tr>
			<tr><td><b>MPolyFromWKB</b><br><b>MultiPolygonFromWKB</b></td>
				<td>MPolyFromWKB( wkbMultiPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_MPolyFromWKB( wkbMultiPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					MultiPolygonFromWKB( wkbMultiPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_MultiPolygonFromWKB( wkbMultiPolygon <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a MultiPolygon</td></tr>
			<tr><td><b>GeomCollFromWKB</b><br><b>GeometryCollectionFromWKB</b></td>
				<td>GeomCollFromWKB( wkbGeometryCollection <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					ST_GeomCollFromWKB( wkbGeometryCollection <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					GeometryCollectionFromWKB( wkbGeometryCollection <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i><hr>
					ST_GeometryCollectionFromWKB( wkbGeometryCollection <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>GeometryCollection</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a GeometryCollection</td></tr>
			<tr><td><b>BdPolyFromWKB</b></td>
				<td>BdPolyFromWKB( wkbMultilinestring <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i><hr>
					ST_BdPolyFromWKB( wkbMultilinestring <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Polygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Construct a Polygon given an arbitrary collection of closed linestrings as a MultiLineString binary representation.
				<hr><i>see also</i>: <b>BuildArea()</b>, <b>Polygonize()</b></td></tr>
			<tr><td><b>BdMPolyFromWKB</b></td>
				<td>BdMPolyFromWKB( wkbMultilinestring <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i><hr>
					ST_BdMPolyFromWKB( wkbMultilinestring <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>MultiPolygon</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Construct a MultiPolygon given an arbitrary collection of closed linestrings as a MultiLineString binary representation.
				<hr><i>see also</i>: <b>BuildArea()</b>, <b>Polygonize()</b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p3">SQL functions for obtaining the Well-known Text / Well-known Binary Representation of a geometric object</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>AsText</b></td>
				<td>AsText( geom <i>Geometry</i> ) : <i>String</i><hr>
					ST_AsText( geom <i>Geometry</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the Well-known Text representation</td></tr>
			<tr><td><b>AsWKT</b></td>
				<td>AsWKT( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the Well-known Text representation<hr>always return strictly conformant 2D WKT</td></tr>
			<tr><td><b>AsBinary</b></td>
				<td>AsBinary( geom <i>Geometry</i> ) : <i>Binary</i><hr>
					ST_AsBinary( geom <i>Geometry</i> ) : <i>Binary</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the Well-known Binary representation</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p3misc">SQL functions supporting exotic geometric formats</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>AsSVG</b></td>
				<td>AsSVG( geom <i>Geometry</i> [ , relative <i>Integer</i> [ , precision <i>Integer</i> ] ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the SVG [<i>Scalable Vector Graphics</i>] representation</td></tr>
			<tr><td><b>AsKml</b></td>
				<td>AsKml( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i><br>
				AsKml( name <i>String</i>, description <i>String</i>, geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ.4</td>
				<td>returns the KML [<i>Keyhole Markup Language</i>] representation<br>
				The first form will simply generate the geometry element: the second form will generate a complete KML entity</td></tr>
			<tr><td><b>GeomFromKml</b></td>
				<td>GeomFromKml( KmlGeometry <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its KML Representation</td></tr>	
			<tr><td><b>AsGml</b></td>
				<td>AsGml( geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i><br>
				AsGml( version <i>Integer</i>, geom <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the GML [<i>Geography Markup Language</i>] representation<br>
				If <i>version = 3</i> than GML 3.x is generated, otherwise the output format will be GML 2.x</td></tr>
			<tr><td><b>GeomFromGML</b></td>
				<td>GeomFromGML( gmlGeometry <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its GML Representation</td></tr>	
			<tr><td><b>AsGeoJSON</b></td>
				<td>AsGeoJSON( geom <i>Geometry</i> [ , precision <i>Integer</i> [ , options <i>Integer</i> ] ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the GeoJSON [<i>Geographic JavaScript Object Notation</i>] representation<hr>
				<i>options</i> can assume the following values:
				<ul>
					<li><b>0</b> no options [<i>default</i>]</li>
					<li><b>1</b> GeoJSON BoundingBox</li>
					<li><b>2</b> GeoJSON CRS [<i>short version</i>]</li>
					<li><b>3</b> BoundingBox + short CRS</li>
					<li><b>4</b> GeoJSON CRS [<i>long version</i>]</li>
					<li><b>5</b> BoundingBox + long CRS</li>
				</ul></td></tr>
			<tr><td><b>GeomFromGeoJSON</b></td>
				<td>GeomFromGeoJSON( geoJSONGeometry <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its GeoJSON Representation</td></tr>	
			<tr><td><b>AsEWKB</b></td>
				<td>AsEWKB( geom <i>Geometry</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the EWKB [<i>Extended Well Known Binary</i>] representation (PostGIS compatibility)</td></tr>
			<tr><td><b>GeomFromEWKB</b></td>
				<td>GeomFromEWKB( ewkbGeometry <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its EWKB Representation</td></tr>	
			<tr><td><b>AsEWKT</b></td>
				<td>AsEWKT( geom <i>Geometry</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the EWKT [<i>Extended Well Known Text</i>] representation (PostGIS compatibility)</td></tr>
			<tr><td><b>GeomFromEWKT</b></td>
				<td>GeomFromEWKT( ewktGeometry <i>String</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its EWKT Representation</td></tr>	
			<tr><td><b>AsFGF</b></td>
				<td>AsFGF( geom <i>Geometry</i> ) : <i>Binary</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the FGF [<i>FDO Geometry Binary Format</i>] representation</td></tr>
			<tr><td><b>GeomFromFGF</b></td>
				<td>GeomFromFGF( fgfGeometry <i>Binary</i> [ , SRID <i>Integer</i>] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>construct a geometric object given its FGF binary Representation</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p4">SQL functions on type Geometry</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Dimension</b></td>
				<td>Dimension( geom <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Dimension( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the dimension of the geometric object, which is less than or equal to the dimension 
					of the coordinate space</td></tr>
			<tr><td><b>CoordDimension</b></td>
				<td>CoordDimension( geom <i>Geometry</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the dimension model used by the geometric object as:<br>
					'<b>XY</b>', '<b>XYZ</b>', '<b>XYM</b>' or '<b>XYZM</b>'</td></tr>
			<tr><td><b>NDims</b></td>
				<td>ST_NDims( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the number of dimensions used by the geometric object as:<br>
					<b>2</b>, <b>3</b> or <b>4</b></td></tr>
			<tr><td><b>Is3D</b></td>
				<td>ST_Is3D( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Checks if <i>geom</i> has the Z dimension.<br>
                                    The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
                                    and -1 for UNKNOWN corresponding to a function invocation on invalid arguments.</td></tr>
			<tr><td><b>IsMeasured</b></td>
				<td>ST_IsMeasured( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Check if <i>geom</i> has the M dimension.<br>
                                    The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
                                    and -1 for UNKNOWN corresponding to a function invocation on invalid arguments.</td></tr>
			<tr><td><b>GeometryType</b></td>
				<td>GeometryType( geom <i>Geometry</i> ) : <i>String</i><hr>
					ST_GeometryType( geom <i>Geometry</i> ) : <i>String</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the name of the instantiable subtype of Geometry of which this geometric object is a member, as a string</td></tr>
			<tr><td><b>SRID</b></td>
				<td>SRID( geom <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_SRID( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the Spatial Reference System ID for this geometric object</td></tr>
			<tr><td><b>SetSRID</b></td>
				<td>SetSRID( geom <i>Geometry</i> , SRID <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>directly sets the Spatial Reference System ID for this geometric object [no reprojection is applied]<hr>
					The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.</td></tr>
			<tr><td><b>IsEmpty</b></td>
				<td>IsEmpty( geom <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_IsEmpty( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.<hr>
					TRUE if this geometric object corresponds to the empty set</td></tr>
			<tr><td><b>IsSimple</b></td>
				<td>IsSimple( geom <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_IsSimple( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.<hr>
					TRUE if this geometric object is simple, as defined in the Geometry Model</td></tr>
			<tr><td><b>IsValid</b></td>
				<td>IsValid( geom <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_IsValid( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.<hr>
					TRUE if this geometric object does  not contains any topological error</td></tr>
			<tr><td><b>IsValidReason</b></td>
				<td>IsValidReason( geom <i>Geometry</i> ) : <i>String</i><hr>
					ST_IsValidReason( geom <i>Geometry</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Will return a TEXT string stating if a Geometry is valid and if not valid, a reason why.<hr>
					NULL will be returned on invalid arguments.</td></tr>
			<tr><td><b>IsValidDetail</b></td>
				<td>IsValidDetail( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_IsValidDetail( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Will return a Geometry detail (usually a <b>POINT</b>) causing invalidity.<hr>
					NULL will be returned on invalid arguments, or in the case of a valid Geometry.</td></tr>
			<tr><td><b>Boundary</b></td>
				<td>Boundary( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Boundary( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>returns a geometric object that is the combinatorial boundary of g as defined in the Geometry Model</td></tr>
			<tr><td><b>Envelope</b></td>
				<td>Envelope( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Envelope( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the rectangle bounding g as a Polygon. The Polygon is defined by the corner points of the bounding
					box [(MINX, MINY),(MAXX, MINY), (MAXX, MAXY), (MINX, MAXY), (MINX, MINY)].</td></tr>
			<tr><td><b>Expand</b></td>
				<td>ST_Expand( geom <i>Geometry</i> , amount <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns the rectangle bounding g as a Polygon. The bounding rectangle is expanded in all directions by an amount 
				    specified by the second argument.</td></tr>
			<tr><td><b>NPoints</b></td>
				<td>ST_NPoints( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the total number of Points (this including any Linestring/Polygon vertex).</td></tr>
			<tr><td><b>NRings</b></td>
				<td>ST_NRings( geom <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the total number of Rings (this including both Exterior and Interior Rings).</td></tr>
			<tr><td><b>Reverse</b></td>
				<td>ST_Reverse( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Geometry [if a valid Geometry was supplied], or NULL in any other case.<hr>
                                    Any Linestring or Ring will be in reverse order (first vertex will be the last one,
                                    and last vertex will be the first one).</td></tr>
			<tr><td><b>ForceLHR</b></td>
				<td>ST_ForceLHR( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Geometry [if a valid Geometry was supplied], or NULL in any other case.<hr>
                                    Any Polygon Ring will be oriented accordingly to Left Hand Rule (Exterior
                                    Ring will be clockwise oriented, and Interior Rings will be counter-clockwise oriented).</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="repair">SQL functions attempting to repair malformed Geometries</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>SanitizeGeometry</b></td>
				<td>SanitizeGeometry( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a (possibly) sanitized Geometry [<i>if a valid Geometry was supplied</i>], or NULL in any other case<hr>
					<u>Please note</u>: current implementations only affects:<ul>
						<li>repeated vertices suppression</li>
						<li>Ring's closure enforcement</li>
					</ul></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="compress">SQL Geometry-compression functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CompressGeometry</b></td>
				<td>CompressGeometry( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a compressed Geometry [<i>if a valid Geometry was supplied</i>], or NULL in any other case<hr>
					<u>Please note</u>: geometry compression only affects LINESTRINGs and POLYGONs, not POINTs</td></tr>
			<tr><td><b>UncompressGeometry</b></td>
				<td>UncompressGeometry( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns an uncompressed Geometry [<i>if a valid Geometry was supplied</i>], or NULL in any other case</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="cast">SQL Geometry-type casting functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CastToPoint</b></td>
				<td>CastToPoint( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>POINT</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing only a single POINT and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToLinestring</b></td>
				<td>CastToLinestring( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>LINESTRING</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing only a single LINESTRING and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToPolygon</b></td>
				<td>CastToPolygon( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>POLYGON</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing only a single POLYGON and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToMultiPoint</b></td>
				<td>CastToMultiPoint( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>MULTIPOINT</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing one or more POINT(s) and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToMultiLinestring</b></td>
				<td>CastToMultiLinestring( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>MULTILINESTRING</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing one or more LINESTRING(s) and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToMultiPolygon</b></td>
				<td>CastToMultiPolygon( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>MULTIPOLYGON</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any Geometry containing one or more POLYGON(s) and no other elementary sub-geometry</td></tr>
			<tr><td><b>CastToGeometyCollection</b></td>
				<td>CastToGeometryCollection( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>GEOMETRYCOLLECTION</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					can be applied to any valid Geometry</td></tr>
			<tr><td><b>CastToMulti</b></td>
				<td>CastToMulti( geom <i>Geometry</i> ) : geom <i>Geometry</i><hr>
					ST_Multi( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>MULTIPOINT-</b>, <b>MULTILINESTRING-</b> or <b>MULTIPOLYGON</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					<ul>
					<li>a MULTIPOINT will be returned for a Geometry containing one or more POINT(s) and no other elementary sub-geometry</li>
					<li>a MULTILINESTRING will be returned for a Geometry containing one or more LINESTRING(s) and no other elementary sub-geometry</li>
					<li>a MULTIPOLYGON will be returned for a Geometry containing one or more POLYGON(s) and no other elementary sub-geometry</li>
					<li>a GEOMETRYCOLLECTION will be returned for any other valid Geometry</li>
					</ul></td></tr>
			<tr><td><b>CastToSingle</b></td>
				<td>CastToSingle( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a <b>POINT-</b>, <b>LINESTRING-</b> or <b>POLYGON</b>-type Geometry [<i>if type-conversion is possible</i>], or NULL in any other case<hr>
					<ul>
					<li>a POINT will be returned for a Geometry containing only a single POINT and no other elementary sub-geometry</li>
					<li>a LINESTRING will be returned for a Geometry containing only a single LINESTRING and no other elementary sub-geometry</li>
					<li>a POLYGON will be returned for a Geometry containing only a single POLYGON and no other elementary sub-geometry</li>
					</ul></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="dims-cast">SQL Space-dimensions casting functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CastToXY</b></td>
				<td>CastToXY( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a Geometry using the [<b>XY</b>] space dimension</td></tr>
			<tr><td><b>CastToXYZ</b></td>
				<td>CastToXYZ( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a Geometry using the [<b>XYZ</b>] space dimension</td></tr>
			<tr><td><b>CastToXYM</b></td>
				<td>CastToXYM( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a Geometry using the [<b>XYZM</b>] space dimension</td></tr>
			<tr><td><b>CastToXYZM</b></td>
				<td>CastToXYZM( geom <i>Geometry</i> ) : geom <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a Geometry using the [<b>XYZM</b>] space dimension</td></tr>
			<tr><td colspan="7" align="center" bgcolor="#f0f0c0">
				<h3><a name="p5">SQL functions on type Point</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>X</b></td>
				<td>X( pt <i>Point</i> ) : <i>Double precision</i><hr>
					ST_X( pt <i>Point</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the x-coordinate of Point p as a double precision number</td></tr>
			<tr><td><b>Y</b></td>
				<td>Y( pt <i>Point</i> ) : <i>Double precision</i><hr>
					ST_Y( pt <i>Point</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the y-coordinate of Point p as a double precision number</td></tr>
			<tr><td><b>Z</b></td>
				<td>Z( pt <i>Point</i> ) : <i>Double precision</i><hr>
					ST_Z( pt <i>Point</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the z-coordinate of Point p as a double precision number<br>
					or NULL is no z-coordinate is available</td></tr>
			<tr><td><b>M</b></td>
				<td>M( pt <i>Point</i> ) : <i>Double precision</i><hr>
					ST_M( pt <i>Point</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the m-coordinate of Point p as a double precision number<br>
					or NULL is no m-coordinate is available</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p6">SQL functions on type Curve [Linestring or Ring]</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>StartPoint</b></td>
				<td>StartPoint( c <i>Curve</i> ) : <i>Point</i><hr>
					ST_StartPoint( c <i>Curve</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a Point containing the first Point of c</td></tr>
			<tr><td><b>EndPoint</b></td>
				<td>EndPoint( c <i>Curve</i> ) : <i>Point</i><hr>
					ST_EndPoint( c <i>Curve</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a Point containing the last Point of c</td></tr>
			<tr><td rowspan="2"><b>Length</b></td>
				<td>GLength( c <i>Curve</i> ) : <i>Double precision</i>
					<table><tbody><tr><td bgcolor="#d080ff">
						OpenGis name for this function is <b>Length()</b>, but it conflicts with an SQLite reserved keyword
					</td></tr></tbody></table><hr>
					ST_Length( c <i>Curve</i> ) : <i>Double precision</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the length of c<hr>
Starting since v.4.0.0 this function will simply consider Linestrings and MultiLinestrings, ignoring any Polygon or MultiPolygon</td></tr>
			<tr><td>GLength( c <i>Curve</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i><hr>
					ST_Length( c <i>Curve</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the length of c (measured in meters).<br>
If the <b>use_ellipsoid</b> argument is set to <b>TRUE</b> the precise (but slower) length will be computed on the Ellipsoid, otherwise will be computed on the Great Cicle (approximative, but faster).<hr>
This function only supports Long/Lat coordinates, and will return NULL for any planar CRS<hr>
Starting since v.4.0.0 this function will simply consider Linestrings and MultiLinestrings, ignoring any Polygon or MultiPolygon</td></tr>
			<tr><td rowspan="2"><b>Perimeter</b></td>
				<td>Perimeter( s <i>Surface</i> ) : <i>Double precision</i>
					ST_Perimeter( s <i>Surface</i> ) : <i>Double precision</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the perimeter of s<hr>
Starting since v.4.0.0 this function will simply consider Polygons and MultiPolygons, ignoring any Linestring or MultiLinestring</td></tr>
			<tr><td>Perimeter( s <i>Surface</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i><hr>
					ST_Perimeter( s <i>Surface</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the perimeter of s (measured in meters).<br>
If the <b>use_ellipsoid</b> argument is set to <b>TRUE</b> the precise (but slower) perimeter will be computed on the Ellipsoid, otherwise will be computed on the Great Cicle (approximative, but faster).<hr>
This function only supports Long/Lat coordinates, and will return NULL for any planar CRS<hr>
Starting since v.4.0.0 this function will simply consider Polygons and MultiPolygons, ignoring any Linestring or MultiLinestring</td></tr>
			<tr><td><b>Geodesic Length</b></td>
				<td>GeodesicLength( c <i>Curve</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>If [<i>and only if</i>] the SRID associated with <i>c</i> is a <b>geographic</b> one [<i>i.e. one using longitude and latitude angles</i>],
				then returns the length of <i>c</i> measured on the Ellipsoid [<i>such length is always expressed in meters</i>]<br>
				Otherwise NULL will be returned<hr>
				<u>Please note:</u> measuring lengths on the Ellipsoid requires complex geodesic calculations, and thus is an
				intrinsically <u>slow and time consuming</u> task</td></tr>
			<tr><td><b>Great Circle Length</b></td>
				<td>GreatCircleLength( c <i>Curve</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>If [<i>and only if</i>] the SRID associated with <i>c</i> is a <b>geographic</b> one [<i>i.e. one using longitude and latitude angles</i>],
				then returns the length of <i>c</i> measured on the Great Circle [<i>such length is always expressed in meters</i>]<br>
				Otherwise NULL will be returned<hr>
				<u>Please note:</u> lengths measured on the Great Circle are less 
precise than lengths measured on the Ellipsoid using complex geodesic 
calculations;
				but they are by far quickest to compute</td></tr>
			<tr><td><b>IsClosed</b></td>
				<td>IsClosed( c <i>Curve</i> ) : <i>Integer</i><hr>
					ST_IsClosed( c <i>Curve</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments;<hr>
					return TRUE if c is closed, i.e., if StartPoint(c) = EndPoint(c)</td></tr>
			<tr><td><b>IsRing</b></td>
				<td>IsRing( c <i>Curve</i> ) : <i>Integer</i><hr>
					ST_IsRing( c <i>Curve</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.<hr>
					return TRUE if c is a ring, i.e., if c is closed and simple. A simple Curve does not pass through 
					the same Point more than once.</td></tr>
			<tr><td><b>PointOnSurface</b></td>
				<td>PointOnSurface( s <i>Surface/Curve</i> ) : <i>Point</i><hr>
					ST_PointOnSurface( s <i>Surface/Curve</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a Point guaranteed to lie on the Surface (or Curve)</td></tr>
			<tr><td><b>Simplify</b></td>
				<td>Simplify( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i><hr>
                                ST_Simplify( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i><hr>
				ST_Generalize( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object representing a simplified version of <i>c</i> applying the Douglas-Peukert 
algorithm with given <i>tolerance</i></td></tr>
			<tr><td><b>SimplifyPreserveTopology</b></td>
				<td>SimplifyPreserveTopology( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i><hr>
                                ST_SimplifyPreserveTopology( c <i>Curve</i> , tolerance <i>Double precision</i> ) : <i>Curve</i></td></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object representing a simplified version of <i>c</i> applying the Douglas-Peukert 
algorithm with given <i>tolerance</i> and respecting topology</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p7">SQL functions on type LineString</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>NumPoints</b></td>
				<td>NumPoints( line <i>LineString</i> ) : <i>Integer</i><hr>
					ST_NumPoints( line <i>LineString</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the number of Points in the LineString</td></tr>
			<tr><td><b>PointN</b></td>
				<td>PointN( line <i>LineString</i> , n <i>Integer</i> ) : <i>Point</i><hr>
					ST_PointN( line <i>LineString</i> , n <i>Integer</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a Point containing Point n of line</td></tr>
			<tr><td><b>AddPoint</b></td>
				<td>AddPoint( line <i>LineString</i> , point <i>Point</i> [ , position <i>Integer</i> ] ) : <i>Linestring</i><hr>
					ST_AddPoint( line <i>LineString</i> , point <i>Point</i> [ , position <i>Integer</i> ] ) : <i>Linestring</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Linestring by adding a new Point into the input Linestring immediately before <b>position</b> (zero-based index).<br>
                                A negative <b>position</b> (default) means appending the new Point to the end of the input Linestring.<br>
                                <b>NULL</b> will be returned if any error is encountered.</td></tr>
			<tr><td><b>SetPoint</b></td>
				<td>SetPoint( line <i>LineString</i> , position <i>Integer</i> , point <i>Point</i> ) : <i>Linestring</i><hr>
					ST_SetPoint( line <i>LineString</i> , position <i>Integer</i> , point <i>Point</i> ) : <i>Linestring</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Linestring by replacing the Point at <b>position</b> (zero-based index).<br>
                                <b>NULL</b> will be returned if any error is encountered.</td></tr>
			<tr><td><b>SetStartPoint</b></td>
				<td>SetStartPoint( line <i>LineString</i> , point <i>Point</i> ) : <i>Linestring</i><hr>
					ST_SetStartPoint( line <i>LineString</i> , point <i>Point</i> ) : <i>Linestring</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Linestring by replacing its StartPoint.<br>
                                <b>NULL</b> will be returned if any error is encountered.</td></tr>
			<tr><td><b>SetEndPoint</b></td>
				<td>SetEndPoint( line <i>LineString</i> , point <i>Point</i> ) : <i>Linestring</i><hr>
					ST_SetEndtPoint( line <i>LineString</i> , point <i>Point</i> ) : <i>Linestring</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Linestring by replacing its EndPoint.<br>
                                <b>NULL</b> will be returned if any error is encountered.</td></tr>
			<tr><td><b>RemovePoint</b></td>
				<td>RemovePoint( line <i>LineString</i> , position <i>Integer</i> ) : <i>Linestring</i><hr>
					ST_RemovePoint( line <i>LineString</i> , position <i>Integer</i> ) : <i>Linestring</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>returns a new Linestring by removing the Point at <b>position</b> (zero-based index).<br>
                                <b>NULL</b> will be returned if any error is encountered.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p8">SQL functions on type Surface [Polygon or Ring]</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Centroid</b></td>
				<td>Centroid( s <i>Surface</i> ) : <i>Point</i><hr>
					ST_Centroid( s <i>Surface</i> ) : <i>Point</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the centroid of s, which may lie outside s</td></tr>
			<tr><td rowspan="2"><b>Area</b></td>
				<td>Area( s <i>Surface</i> ) : <i>Double precision</i><hr>
					ST_Area( s <i>Surface</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the area of s</td></tr>
			<tr><td>Area( s <i>Surface</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i><hr>
					ST_Area( s <i>Surface</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return the area of s (measured in meters).<br>
If the <b>use_ellipsoid</b> argument is set to <b>TRUE</b> the precise (but slower) area will be computed on the Ellipsoid, otherwise will be computed on the Sphere (approximative, but faster).<hr>
This function only supports Long/Lat coordinates, and will return NULL for any planar CRS</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p9">SQL functions on type Polygon</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>ExteriorRing</b></td>
				<td>ExteriorRing( polyg <i>Polygon</i> ) : <i>LineString</i><hr>
					ST_ExteriorRing( polyg <i>Polygon</i> ) : <i>LineString</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the exteriorRing of p</td></tr>
			<tr><td><b>NumInteriorRing</b><br><b>NumInteriorRings</b></td>
				<td>NumInteriorRing( polyg <i>Polygon</i> ) : <i>Integer</i><hr>
					NumInteriorRings( polyg <i>Polygon</i> ) : <i>Integer</i><hr>
					ST_NumInteriorRing( polyg <i>Polygon</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the number of interiorRings</td></tr>
			<tr><td><b>InteriorRingN</b></td>
				<td>InteriorRingN( polyg <i>Polygon</i> , n <i>Integer</i> ) : <i>LineString</i><hr>
					ST_InteriorRingN( polyg <i>Polygon</i> , n <i>Integer</i> ) : <i>LineString</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the nth interiorRing. The order of Rings is not geometrically significant.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p10">SQL functions on type GeomCollection</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>NumGeometries</b></td>
				<td>NumGeometries( geom <i>GeomCollection</i> ) : <i>Integer</i><hr>
					ST_NumGeometries( geom <i>GeomCollection</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the number of individual Geometries</td></tr>
			<tr><td><b>GeometryN</b></td>
				<td>GeometryN( geom <i>GeomCollection</i> , n <i>Integer</i> ) : <i>Geometry</i><hr>
					ST_GeometryN( geom <i>GeomCollection</i> , n <i>Integer</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the nth geometric object in the collection.
					The order of the elements in the collection is not geometrically significant.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p11">SQL functions that test approximate spatial relationships via MBRs</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>MbrEqual</b></td>
				<td>MbrEqual( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if g1 and g2 have equal MBRs</td></tr>
			<tr><td><b>MbrDisjoint</b></td>
				<td>MbrDisjoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if the intersection of g1 and g2 MBRs is the empty set</td></tr>
			<tr><td><b>MbrTouches</b></td>
				<td>MbrTouches( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if the only Points in common between g1 and g2 MBRs lie in the union of the boundaries of g1 and g2</td></tr>
			<tr><td><b>MbrWithin</b></td>
				<td>MbrWithin( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if g1 MBR is completely contained in g2 MBR</td></tr>
			<tr><td><b>MbrOverlaps</b></td>
				<td>MbrOverlaps( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if the intersection of g1 and g2 MBRs results in a value of the same
					dimension as g1 and g2 that is different from both g1 and g2</td></tr>
			<tr><td><b>MbrIntersects</b></td>
				<td>MbrIntersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments;<br>
					convenience predicate: TRUE if the intersection of g1 and g2 MBRs is not empty</td></tr>
			<tr><td><b>EnvelopesIntersects</b></td>
				<td>ST_EnvIntersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
				    ST_EnvelopesIntersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
				    ST_EnvIntersects( geom1 <i>Geometry</i> , x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> ) : <i>Integer</i><hr>
				    ST_EnvelopesIntersects( geom1 <i>Geometry</i> , x1 <i>Double precision</i> , y1 <i>Double precision</i> , x2 <i>Double precision</i> , y2 <i>Double precision</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The first form simply is an <u>alias name</u> for <b>MbrIntersects</b>; the other form allows to define the second MBR by two extreme points [<b>x1, y1</b>] and [<b>x2, y2</b>].<br>
                                        The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on invalid arguments;<br>
					convenience predicate: TRUE if the intersection of both MBRs is not empty</td></tr>
			<tr><td><b>MbrContains</b></td>
				<td>MbrContains( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments;<hr>
					convenience predicate: TRUE if g2 MBR is completely contained in g1 MBR</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p12">SQL functions that test spatial relationships</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Equals</b></td>
				<td>Equals( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Equals( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if g1 and g2 are equal</td></tr>
			<tr><td><b>Disjoint</b></td>
				<td>Disjoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Disjoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if the intersection of g1 and g2 is the empty set</td></tr>
			<tr><td><b>Touches</b></td>
				<td>Touches( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Touches( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if the only Points in common between g1 and g2 lie in the union of the boundaries of g1 and g2</td></tr>
			<tr><td><b>Within</b></td>
				<td>Within( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Within( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if g1 is completely contained in g2</td></tr>
			<tr><td><b>Overlaps</b></td>
				<td>Overlaps( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Overlaps( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if the intersection of g1 and g2 results in a value of the same
					dimension as g1 and g2 that is different from both g1 and g2</td></tr>
			<tr><td><b>Crosses</b></td>
				<td>Crosses( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Crosses( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments.<hr>
					TRUE if the intersection of g1 and g2 results in a value whose dimension is less 
					than the maximum dimension of g1 and g2 and the intersection value includes Points 
					interior to both g1 and g2, and the intersection value is not equal to either g1 or g2</td></tr>
			<tr><td><b>Intersects</b></td>
				<td>Intersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Intersects( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments;<br>
					convenience predicate: TRUE if the intersection of g1 and g2 is not empty</td></tr>
			<tr><td><b>Contains</b></td>
				<td>Contains( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Contains( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments;<hr>
					convenience predicate: TRUE if g2 is completely contained in g1</td></tr>
			<tr><td><b>Covers</b></td>
				<td>Covers( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_Covers( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments;<hr>
					convenience predicate: TRUE if g1 completely covers g2</td></tr>
			<tr><td><b>CoveredBy</b></td>
				<td>CoveredBy( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i><hr>
					ST_CoveredBy( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments;<hr>
					convenience predicate: TRUE if g1 is completely covered by g2</td></tr>
			<tr><td><b>Relate</b></td>
				<td>Relate( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , patternMatrix <i>String</i> ) : <i>Integer</i><hr>
					ST_Relate( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , patternMatrix <i>String</i> ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, 
					and &#8211;1 for UNKNOWN corresponding to a function invocation on NULL arguments;<hr>
					returns TRUE if the spatial relationship specified by the patternMatrix holds</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p13">SQL functions for distance relationships</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td rowspan="2"><b>Distance</b></td>
				<td>Distance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i><hr>
					ST_Distance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the distance between geom1 and geom2 (always measured in CRS units).</td></tr>
			<tr><td>Distance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i><hr>
					ST_Distance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , use_ellipsoid <i>Boolean</i> ) : <i>Double precision</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the distance between geom1 and geom2 (measured in meters).<br>
If the <b>use_ellipsoid</b> argument is set to <b>TRUE</b> the precise (but slower) distance will be computed on the Ellipsoid, otherwise will be computed on the Great Cicle (approximative, but faster).<hr>
This function only supports Long/Lat coordinates, and will return NULL for any planar CRS</td></tr>
			<tr><td><b>PtDistWithin</b></td>
				<td>PtDistWithin( geom1 <i>Geometry</i> , geom2 <i>Geometry</i>, range <i>Double precision</i> [, use_spheroid <i>Integer</i> ] ) 
					: <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ.4</td>
				<td>return TRUE (1) if the distance between <i>geom1</i> and <i>geom2</i> is within the given range.<br>
				Usually distances are expressed in the length unit corresponding to the geoms own SRID:
				but if both geoms are simple POINTs and their SRID is 4326 (i.e. WGS84), then distances are
				expressed in <b>meters</b>.<br>
				In this later case the optional arg <i>use_spheroid</i> can be used to select the distance
				algorithm to be used: is <i>use_spheroid = 1</i> the slowest but most accurate <b>geodesic distance</b>
				will be evaluated: in any other case the simplest <b>great circle distance</b> will be used instead</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p14">SQL functions that implement spatial operators</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Intersection</b></td>
				<td>Intersection( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Intersection( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the intersection of geometric objects geom1 and geom2</td></tr>
			<tr><td><b>Difference</b></td>
				<td>Difference( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Difference( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the closure of the set difference of geom1 and geom2</td></tr>
			<tr><td><b>GUnion</b></td>
				<td>GUnion( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i>
					<table><tbody><tr><td bgcolor="#d080ff">
						OpenGis name for this function is <b>Union()</b>, but it conflicts with an SQLite reserved keyword
					</td></tr></tbody></table><hr>
					ST_Union( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i>
				</td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the set union of geom1 and geom2</td></tr>
			<tr><td><b>GUnion</b></td>
				<td>GUnion( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Union( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the set union of input values
				<b><u>aggregate function</u></b></td></tr>
			<tr><td><b>SymDifference</b></td>
				<td>SymDifference( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_SymDifference( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the closure of the set symmetric difference of geom1 and geom2 
					(logical XOR of space)</td></tr>
			<tr><td><b>Buffer</b></td>
				<td>Buffer( geom <i>Geometry</i> , dist <i>Double precision</i> [ , quadrantsegments <i>Integer</i> ] ) : <i>Geometry</i><hr>
					ST_Buffer( geom <i>Geometry</i> , dist <i>Double precision</i> [ , quadrantsegments <i>Integer</i> ] ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object defined by buffering a distance d around geom, 
					where dist is in the distance units for the Spatial Reference of geom.<hr>
					the optional <b>quadrantsegments</b> argument specifies the number of segments used to approximate a quarter circle (default is 30).</td></tr>
			<tr><td><b>ConvexHull</b></td>
				<td>ConvexHull( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_ConvexHull( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object that is the convex hull of geom</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p14b">SQL functions that implement spatial operators<br>[GEOS specific features]</a></h3></td></tr>
			<tr><td><b>HausdorffDistance</b></td>
				<td>HausdorffDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i><hr>
					ST_HausdorffDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return the Hausdorff distance between geom1 and geom2<br>
				<a href="http://en.wikipedia.org/wiki/Hausdorff_distance">learn more</a></td></tr>
			<tr><td><b>OffestCurve</b></td>
				<td>OffsetCurve( geom <i>Curve</i> , radius <i>Double precision</i> ) : <i>Curve</i><hr>
					ST_OffsetCurve( geom <i>Curve</i> , radius <i>Double precision</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object representing the corresponding <i>left-sided</i> (<b>positive radius</b>) 
					or <i>right-sided</i> (<b>negative radius</b>) offset curve<br>
					NULL is returned whenever is not possible deriving an offset curve from the original geometry<br>
					[a single not-closed LINESTRING is expected as input]</td></tr>
			<tr><td><b>SingleSidedBuffer</b></td>
				<td>SingleSidedBuffer( geom <i>Curve</i> , radius <i>Double precision</i> , left_or_right <i>Integer</i> ) : <i>Curve</i><hr>
					ST_SingleSidedBuffer( geom <i>Curve</i> , radius <i>Double precision</i> , left_or_right <i>Integer</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object representing the corresponding <i>left-</i> (or <i>right-sided</i>) single-sided buffer<br>
					NULL is returned whenever is not possible deriving a single-sided buffer from the original geometry<br>
					[a single not-closed LINESTRING is expected as input]</td></tr>
			<tr><td><b>SharedPaths</b></td>
				<td>SharedPaths( geom1 <i>Geometry</i> , geom2 <i>Geomety</i> ) : <i>Geometry</i><hr>
					ST_SharedPaths( geom1 <i>Geometry</i> , geom2 <i>Geomety</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a geometric object (of the MULTILINESTRING type) representing any <i>common lines</i> shared by both geometries<br>
					NULL is returned is no common line exists</td></tr>
			<tr><td><b>Line_Interpolate_Point</b></td>
				<td>Line_Interpolate_Point( line <i>Curve</i> , fraction <i>Double precision</i> ) : <i>Point</i><hr>
					ST_Line_Interpolate_Point( line <i>Curve</i> , fraction <i>Double precision</i> ) : <i>Point</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a point interpolated along a line.<br>
					Second argument (between <b>0.0</b> and <b>1.0</b>) representing fraction of total length of linestring 
					the point has to be located.<br>
					NULL is returned for invalid arguments</td></tr>
			<tr><td><b>Line_Interpolate_Equidistant_Points</b></td>
				<td>Line_Interpolate_Equidistant_Points( line <i>Curve</i> , distance <i>Double precision</i>) : <i>MultiPoint</i><hr>
					ST_Line_Interpolate_Equidistant_Points( line <i>Curve</i> , distance <i>Double precision</i> ) : <i>MultiPoint</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a set of equidistant points interpolated along a line; the returned geometry
					always corresponds to a MULTIPOINT supporting the M coordinate (representing the
                                        progressive distance for each interpolated Point).<br>
					Second argument represents the regular distance between interpolated points.<br>
					NULL is returned for invalid arguments</td></tr>
			<tr><td><b>Line_Locate_Point</b></td>
				<td>Line_Locate_Point( line <i>Curve</i> , point <i>Point</i> ) : <i>Double precision</i><hr>
					ST_Line_Locate_Point( line <i>Curve</i> , point <i>Point</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>return a number (between <b>0.0</b> and <b>1.0</b>) representing the location of the closest 
					point on LineString to the given Point, as a fraction of total 2d line length.<br>
					NULL is returned for invalid arguments</td></tr>
			<tr><td><b>Line_Substring</b></td>
				<td>Line_Substring( line <i>Curve</i> , start_fraction <i>Double precision</i> , 
					end_fraction <i>Double precision</i> ) : <i>Curve</i><hr>
					ST_Line_Substring( line <i>Curve</i> , start_fraction <i>Double precision</i> , 
					end_fraction <i>Double precision</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Return a Linestring being a substring of the input one starting and ending at the given fractions of total 2d length.<br>
					Second and third arguments are expected to be in the range between <b>0.0</b> and <b>1.0</b>.<br>
					NULL is returned for invalid arguments</td></tr>
			<tr><td><b>ClosestPoint</b></td>
				<td>ClosesetPoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Point</i><hr>
					ST_ClosesetPoint( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Point</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Returns the Point on geom1 that is closest to geom2.<br>
					NULL is returned for invalid arguments (or if distance is ZERO)</td></tr>
			<tr><td><b>ShortestLine</b></td>
				<td>ShortestLine( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Curve</i><hr>
					ST_ShortestLine( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Curve</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Returns the shortest line between two geometries.<br>
					NULL is returned for invalid arguments (or if distance is ZERO)</td></tr>
			<tr><td><b>Snap</b></td>
				<td>Snap( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Geometry</i><hr>
					ST_Snap( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> , tolerance <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Returns a new Geometry representing a modified <b>geom1</b>, so to "snap" vertices and segments to <b>geom2</b> vertices;
					a snap distance tolerance is used to control where snapping is performed.<br>
					NULL is returned for invalid arguments</td></tr>
			<tr><td><b>Collect</b></td>
				<td>Collect( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Collect( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>a generic Geometry (possibly a GEOMETRYCOLLECTION) will be returned merging <b>geom1</b> and <b>geom2</b><hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>Collect</b></td>
				<td>Collect( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Collect( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>a generic Geometry (possibly a GEOMETRYCOLLECTION) will be returned merging input Geometries all together<br>
				<b><u>aggregate function</u></b><hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>LineMerge</b></td>
				<td>LineMerge( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_LineMerge( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>a Geometry (actually corresponding to a <i>LINESTRING</i> or <i>MULTILINESTRING</i>) will be returned.<br>
				The input Geometry is expected to represent a <i>LINESTRING</i> or a <i>MULTILINESTRING</i>.<br> 
				The input Geometry can be an arbitrary collection of sparse line fragments: this
				function will then try to (possibly) reassemble them into one (or more) Linestring(s).<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>BuildArea</b></td>
				<td>BuildArea( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_BuildArea( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>a Geometry (actually corresponding to a <i>POLYGON</i> or <i>MULTIPOLYGON</i>) will be returned.<br>
				The input Geometry is expected to represent a <i>LINESTRING</i> or a <i>MULTILINESTRING</i>.<br> 
				The input Geometry can be an arbitrary collection of sparse Linestrings: this
				function will then try to (possibly) reassemble them into one (or more) polygon(s).<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>Polygonize</b></td>
				<td>Polygonize( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_Polygonize( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Exactly the same as <b>ST_BuildArea</b>, but implemented as an <b><u>aggregate function</u></b>.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>MakePolygon</b></td>
				<td>MakePolygon( geom1 <i>Geometry</i> [ , geom2 <i>Geometry</i> ] ) : <i>Geometry</i><hr>
					ST_MakePolygon( geom1 <i>Geometry</i> [ , geom2 <i>Geometry</i> ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Kind of lightweight/simplified <b>ST_BuildArea</b>: the first input Geometry is always expected to represent a closed <i>LINESTRING</i> assumed to identify the output polygon's Exterior Ring.<br>
                                The second input Geometry (if any) is expected to be a <i>LINESTRING</i> or <i>MULTILINESTRING</i> identifying any polygon's Interior Ring (and all them are expected to be correctly closed).<br>
                                <b><u>Please note well</u></b>: this function doesn't perform any internal topology check, so it could possibly return an invalid polygon on invalid input.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>UnaryUnion</b></td>
				<td>UnaryUnion( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_UnaryUnion( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0d0">GEOS</td>
				<td>Exactely the same as <b><u>ST_Union</u></b>, but applied to a single Geometry.<br>
					(<i>set union of elementary Geometries within a MULTI- or GEOMETRYCOLLECTION complex Geometry</i>)<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>DissolveSegments</b></td>
				<td>DissolveSegments( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_DissolveSegments( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry (actually corresponding to a <i>LINESTRING</i>, <i>MULTILINESTRING</i> or <i>GEOMETRYCOLLECTION</i>) 
				will be returned.<br>
				The input Geometry is arbitrary: any <i>POINT</i> will remain unaffected, but any <i>LINESTRING</i>
				or <i>RING</i> will be dissolved into elementary segments.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>DissolvePoints</b></td>
				<td>DissolvePoints( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_DissolvePoints( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry (actually corresponding to a <i>POINT</i> or <i>MULTIPOINT</i>) 
				will be returned.<br>
				The input Geometry is arbitrary: any <i>POINT</i> will remain unaffected, but any <i>LINESTRING</i>
				or <i>RING</i> will be dissolved into elementary Points corresponding to each Vertex.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>LinesFromRings</b></td>
				<td>LinesFromRings( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_LinesFromRings( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry (actually corresponding to a <i>LINESTRING</i> or <i>MULTILINESTRING</i>) 
				will be returned.<br>
				The input Geometry is expected to be a <i>POLYGON</i> or <i>MULTIPOLYGON</i>;
				any <i>RING</i> will then be transformed into the corresponding <i>LINESTRING</i>.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>LinesCutAtNodes</b></td>
				<td>LinesCutAtNodes( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_LinesCutAtNodes( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry (actually corresponding to a <i>LINESTRING</i> or <i>MULTILINESTRING</i>) 
				will be returned.<br>
				The first input Geometry is expected to be a <i>LINESTRING</i> or <i>MULTILINESTRING</i> (<b>Lines</b>);
				the second input Geometry is expected to be a <i>POINT</i> or <i>MULTIPOINT</i> (<b>Nodes</b>).<br>
				any <i>Line</i> will then be possibly split in two halves where some vertex exactly intercepts a <i>Node</i>.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>RingsCutAtNodes</b></td>
				<td>RingsCutAtNodes( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_RingsCutAtNodes( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>a Geometry (actually corresponding to a <i>LINESTRING</i> or <i>MULTILINESTRING</i>) 
				will be returned.<br>
				The input Geometry is expected to be a <i>POLYGON</i> or <i>MULTIPOLYGON</i> (<b>Rings</b>);
				any self-intersection or intersection between Rings is assumed to represent a <b>Node</b>.<br>
				any <i>Ring</i> will then be possibly split in two halves where some vertex exactly intercepts a <i>Node</i>.<hr>
				NULL will be returned if any error is encountered</td></tr>
			<tr><td><b>CollectionExtract</b></td>
				<td>CollectionExtract( geom <i>Geometry</i> , type <i>Integer</i> ) : <i>Geometry</i><hr>
					ST_CollectionExtract( geom <i>Geometry</i> , type <i>Integer</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Given any arbitrary GEOMETRY will return a derived geometry consisting only of the specified type.
				Sub-geometries that are not the specified type are ignored.<br>
				<ul>
					<li><b>1</b> = POINT-type</li>
					<li><b>2</b> = LINESTRING-type</li>
					<li><b>3</b> = POLYGON-type</li>
				</ul>
				NULL will be returned if any error is encountered (or when no item of required type is found)<br>
				The Type of the returned Geometry could be e.g. <b>POINT</b> or <b>MULTIPOINT</b> depending on actual items count.</td></tr>
			<tr><td><b>ExtractMultiPoint</b></td>
				<td>ExtractMultiPoint( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Given any arbitrary GEOMETRY will return a derived <b>MULTIPOINT</b> geometry.
				Sub-geometries not being of the <b>POINT</b> type will be ignored.<br>
				NULL will be returned if any error is encountered (or when no POINT is found).</td></tr>
			<tr><td><b>ExtractMultiLinestring</b></td>
				<td>ExtractMultiLinestring( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Given any arbitrary GEOMETRY will return a derived <b>MULTILINESTRING</b> geometry.
				Sub-geometries not being of the <b>LINESTRING</b> type will be ignored.<br>
				NULL will be returned if any error is encountered (or when no LINESTRING is found).</td></tr>
			<tr><td><b>ExtractMultiPolygon</b></td>
				<td>ExtractMultiPolygon( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Given any arbitrary GEOMETRY will return a derived <b>MULTIPOLYGON</b> geometry.
				Sub-geometries not being of the <b>POLYGON</b> type will be ignored.<br>
				NULL will be returned if any error is encountered (or when no POLYGON is found).</td></tr>
			<tr><td><b>LocateAlongMeasure</b></td>
				<td>ST_Locate_Along_Measure( geom <i>Geometry</i> , m_value <i>Double precision</i> ) : <i>Geometry</i><hr>
				    ST_LocateAlong( geom <i>Geometry</i> , m_value <i>Double precision</i> ) : <i>Geometry</i></hr></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Return a derived geometry collection value with elements that match the specified measure.<br>
				NULL will be returned if any error is encountered (or when no element corresponding to the given measure is found).<br>
                                <u>Please note</u>: NULL will be returned if geom doesn't contain M-dimension, or if geom contains a Polygon, or if geom is a GeometryCollection.</td></tr>
			<tr><td><b>LocateBetweenMeasures</b></td>
				<td>ST_Locate_Between_Measures( geom <i>Geometry</i> , m_start <i>Double precision</i> , m_end <i>Double precision</i> ) : <i>Geometry</i><hr>
				    ST_LocateBetween( geom <i>Geometry</i> , m_start <i>Double precision</i> , m_end <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Return a derived geometry collection value with elements that match the specified range of measures.<br>
				NULL will be returned if any error is encountered (or when no element corresponding to the given range of measures is found).<br>
                                <u>Please note</u>: NULL will be returned if geom doesn't contain M-dimension, or if geom contains a Polygon, or if geom is a GeometryCollection.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p14c">SQL functions that implement spatial operators<br>[GEOS advanced features]</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>DelaunayTriangulation</b></td>
				<td>DelaunayTriangulation( geom <i>Geometry</i> [ , edges_only <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ) : <i>Geometry</i><hr>
					ST_DelaunayTriangulation( geom <i>Geometry</i> [ , edges_only <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0b0">GEOS-advanced</td>
				<td>return a geometric object representing the Delaunay Triangulation corresponding to the input Geometry<hr>
					The input Geometry could have any arbitrary type; eventually all Linestring's / Polygon's vertices will be dissolved into Points, so to implicitly always get a MultiPoint.<br>
					The returned Geometry will usually be of the <b>MultiPolygon</b> type (a collection of Triangles), but will be a <b>MultiLinestring</b> if the optional <b>edges_only</b> argument is set to <b>TRUE</b><br>
                                        The optional argument <b>tolerance</b> is intended to normalize the input Geometry, suppressing repeated (or too close) Points.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>VoronojDiagram</b></td>
				<td>VoronojDiagram( geom <i>Geometry</i> [ , edges_only <i>Boolean</i> [ , frame_extra_size <i>Double precision</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i><hr>
					ST_VoronojDiagram( geom <i>Geometry</i> [ , edges_only <i>Boolean</i>  [ , frame_extra_size <i>Double precision</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0b0">GEOS-advanced</td>
				<td>return a geometric object representing the Voronoj Diagram corresponding to the input Geometry<hr>
					The input Geometry could have any arbitrary type; eventually all Linestring's / Polygon's vertices will be dissolved into Points, so to implicitly always get a MultiPoint.<br>
					The returned Geometry will usually be of the <b>MultiPolygon</b> type, but will be a <b>MultiLinestring</b> if the optional <b>edges_only</b> argument is set to <b>TRUE</b><br>
                                        The optional argument <b>extra_frame_size</b> allows to arbitrarily set the <i>percent</i> extension of the bounding frame: the default value is <b>5%</b>.<br>
                                        The optional argument <b>tolerance</b> is intended to normalize the input Geometry, suppressing repeated (or too close) Points.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>ConcaveHull</b></td>
				<td>ConcaveHull( geom <i>Geometry</i> [ , factor <i>Double precision</i> [ , allow_holes <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i><hr>
					ST_ConcaveHull( geom <i>Geometry</i> [ , factor <i>Double precision</i> [ , allow_holes <i>Boolean</i> [ , tolerance <i>Double precision</i> ] ] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0b0">GEOS-advanced</td>
				<td>return a geometric object representing the ConcaveHull corresponding to the input Geometry<hr>
					The input Geometry could have any arbitrary type; eventually all Linestring's / Polygon's vertices will be dissolved into Points, so to implicitly always get a MultiPoint.<br>
					The returned Geometry will always be of the <b>Polygon</b> or <b>MultiPolygon</b> type.<br>
                                        The default <b>factor</b> applies a <b>3&sigma;</b> filtering; by declaring some <i>lower</i> factor you can get a more aggressive filtering effect.<br>
                                        By setting the optional <b>allow_holes</b> argument to <b>TRUE</b> all <i>interior holes</i> will be preserved.<br>
                                        The optional argument <b>tolerance</b> is intended to normalize the input Geometry, suppressing repeated (or too close) Points.<br>
					NULL is returned on failure.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p14d">SQL functions that implement spatial operators<br>[LWGEOM features]</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>MakeValid</b></td>
				<td>MakeValid( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_MakeValid( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return a geometric object representing the <i>repaired</i> version of the input Geometry.<br>
                                        If the input Geometry was already valid, then it will be returned exactly as it was.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>MakeValidDiscarded</b></td>
				<td>MakeValidDiscarded( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					ST_MakeValidDiscarded( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return a geometric object containing all elements that would be eventually <i>discarded</i> by ST_MakeValid() while validating the same input Geometry.<br>
					NULL is returned on failure, or if no <i>discarded</i> item exists.</td></tr>
			<tr><td><b>Segmentize</b></td>
				<td>Segmentize( geom <i>Geometry</i>, dist <i>Double precision</i>  ) : <i>Geometry</i><hr>
					ST_Segmentize( geom <i>Geometry</i> , dist <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return a new Geometry corresponding to the input Geometry; as much Linestring / Ring vertices 
                                        as required will be eventually interpolated so to ensure that no segment will be longer than <i>dist</i>.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>Split</b></td>
				<td>Split( geom <i>Geometry</i>, blade <i>Geometry</i>  ) : <i>Geometry</i><hr>
					ST_Split( geom <i>Geometry</i> , blade <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return a new Geometry collecting all items resulting by splitting the input Geometry by the <i>blade</i>.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>SplitLeft</b></td>
				<td>SplitLeft( geom <i>Geometry</i>, blade <i>Geometry</i>  ) : <i>Geometry</i><hr>
					ST_SplitLeft( geom <i>Geometry</i> , blade <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return a new Geometry collecting all items resulting by splitting the input Geometry by the <i>blade</i> and falling on the <i>left side</i>.<br>
                                        All items not affected by the split operation (i.e. not intersecting the <i>blade</i>) will be returned into the <i>left</i> collection.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>SplitRight</b></td>
				<td>SplitRight( geom <i>Geometry</i>, blade <i>Geometry</i>  ) : <i>Geometry</i><hr>
					ST_SplitRight( geom <i>Geometry</i> , blade <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return a new Geometry collecting all items resulting by splitting the input Geometry by the <i>blade</i> and falling on the <i>right side</i>.<br>
					NULL is returned on failure (or if the <i>right side</i> is empty).</td></tr>
			<tr><td><b>Azimuth</b></td>
				<td>Azimuth( pt1 <i>Geometry</i>, pt2 <i>Geometry</i>  ) : <i>Double precision</i><hr>
					ST_Azimuth( pt1 <i>Geometry</i> , pt2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return the angle (in radians) from the horizontal of the vector defined by <b>pt1</b> and <b>pt2</b>.<br>
                                        Both <b>pt1</b> and <b>pt2</b> are expected to be simple Points.<br>
					Starting since <u>4.1.0</u> if both points supports <u>long/lat</u> coords the returned Azimuth will be precisely computed on the ellipsoid.<br>
					NULL is returned on failure.<hr>
                                        On the clock: 12=0; 3=PI/2; 6=PI; 9=3PI/2</td></tr>
			<tr><td><b>Project</b></td>
				<td>Project( start_point <i>Geometry</i>, distance <i>Double precision</i>, azimuth <i>Double precision</i>  ) : <i>Geometry</i><hr>
					ST_Project( start_point <i>Geometry</i>, distance <i>Double precision</i>, azimuth <i>Double precision</i>  ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return a new Point projected from a start point using a bearing and distance.<br>
                                        <b>start_point</b> is expected to be simple <u>long/lat</u> Point.<br>
					<b>distance</b> is expected to be measured in <u>meters</u>; <b>azimuth</b> (aka <u>bearing</u> or <u>heading</u>) has the same identical meaning as in <b>ST_Azimuth()</b>.<br>
					NULL is returned on failure or on invalid arguments.</td></tr>
			<tr><td><b>SnapToGrid</b></td>
				<td>SnapToGrid( geom <i>Geometry</i> , size <i>Double precision</i>  ) : <i>Geometry</i><br>
				        SnapToGrid( geom <i>Geometry</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> ) : <i>Geometry</i><br>
				        SnapToGrid( geom <i>Geometry</i> , origin_x <i>Double precision</i> , origin_y <i>Double precision</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> ) : <i>Geometry</i><br>
                                        SnapToGrid( geom <i>Geometry</i> , origin <i>Geometry</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> , size_z <i>Double precision</i> , size_m <i>Double precision</i> ) : <i>Geometry</i><hr>
					ST_SnapToGrid( geom <i>Geometry</i> , size <i>Double precision</i>  ) : <i>Geometry</i><br>
					ST_SnapToGrid( geom <i>Geometry</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> )  ) : <i>Geometry</i><br>
                                        ST_SnapToGrid( geom <i>Geometry</i> , origin_x <i>Double precision</i> , origin_y <i>Double precision</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> )  ) : <i>Geometry</i><br>
                                        ST_SnapToGrid( geom <i>Geometry</i> , origin <i>Geometry</i> , size_x <i>Double precision</i> , size_y <i>Double precision</i> , size_z <i>Double precision</i> , size_m <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a new Geometry corresponding to the input Geometry; all points and vertices will be snapped to the grid defined by its origin and size(s).<br>
                                        Removes all consecutive points falling on the same cell.<br>
                                        All collapsed geometries will be stripped from the returned Geometry.<br>
					NULL is returned on failure.</td></tr>
			<tr><td><b>GeoHash</b></td>
				<td>GeoHash( geom <i>Geometry</i> ) : <i>String</i><hr>
					ST_GeoHash( geom <i>Geometry</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>Return a GeoHash representation (geohash.org) of the geometry.<br>
                                    A GeoHash encodes a point into a text form that is sortable and searchable based on prefixing.<hr>
                                    ST_GeoHash will not work with geometries that are not in geographic (lon/lat) coordinates</td></tr>
			<tr><td><b>AsX3D</b></td>
				<td>AsX3D( geom <i>Geometry</i> ) : <i>String</i><br>
				AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> ) : <i>String</i><br>
				AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> , options <i>Integer</i> ) : <i>String</i><br>
				AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> , options <i>Integer</i> , refid <i>String</i> ) : <i>String</i><hr>
				ST_AsX3D( geom <i>Geometry</i> ) : <i>String</i><br>
				ST_AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> ) : <i>String</i><br>
				ST_AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> , options <i>Integer</i> ) : <i>String</i><br>
				ST_AsX3D( geom <i>Geometry</i> , precision <i>Integer</i> , options <i>Integer</i> , refid <i>String</i> ) : <i>String</i>
</td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>Returns a geometry as an X3D XML formatted node element.</td></tr>
			<tr><td><b>MaxDistance</b></td>
				<td>MaxDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i><hr>
					ST_MaxDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return the max distance between geom1 and geom2</td></tr>
			<tr><td><b>3DDistance</b></td>
				<td>ST_3DDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return the 3D-distance between geom1 and geom2 (Z coordinates will be considered)</td></tr>
			<tr><td><b>3DMaxDistance</b></td>
				<td>ST_3DMaxDistance( geom1 <i>Geometry</i> , geom2 <i>Geometry</i> ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>return the max 3D-distance between geom1 and geom2 (Z coordinates will be considered)</td></tr>
			<tr><td><b>ST_Node</b></td>
				<td>ST_Node( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>Fully nodes a set of linestrings using the least possible number of nodes while preserving all of the input ones.<br>
                                <b>NULL</b> will be returned if the input Geometry isn't a set of linestrings or if any other error occurs.</td></tr>
			<tr><td><b>SelfIntersections</b></td>
				<td>SelfIntersections( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
                                	ST_SelfIntersections( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#f0d0f0">LWGEOM</td>
				<td>Returns a MultiPoint Geometry representing any self-intersection found within the input geometry
					[expected to be of the Linestring or MultiLinestring type].<br>
                                <b>NULL</b> will be returned for invalid arguments, or when no self-intersections were found.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p15">SQL functions for coordinate transformations</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>Transform</b></td>
				<td>Transform( geom <i>Geometry</i> , newSRID <i>Integer</i> ) : <i>Geometry</i><br>
					ST_Transform( geom <i>Geometry</i> , newSRID <i>Integer</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0d0f0">PROJ.4</td>
				<td>return a geometric object obtained by reprojecting coordinates into the Reference System identified by newSRID</td></tr>
			<tr><td><b>SridFromAuthCRS</b></td>
				<td>SridFromAuthCRS( auth_name <i>String</i> , auth_SRID <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the internal SRID corresponding to <b>auth_name</b> and <b>auth_SRID</b><br>
				<b>-1</b> will be returned if no such CRS is defined </td></tr>
			<tr><td><b>ShiftCoords</b><br><b>ShiftCoordinates</b></td>
				<td>ShiftCoords( geom <i>Geometry</i> , shiftX <i>Double precision</i> , shiftY <i>Double precision</i> ) : <i>Geometry</i><hr>
					ShiftCoordinates( geom <i>Geometry</i> , shiftX <i>Double precision</i> , shiftY <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by translating coordinates according to shiftX and shiftY values</td></tr>
			<tr><td><b>ST_Translate</b></td>
				<td>ST_Translate( geom <i>Geometry</i> , shiftX <i>Double precision</i> , shiftY <i>Double precision</i> , shiftZ <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by translating coordinates according to shiftX, shiftY and shiftZ values</td></tr>
			<tr><td><b>ST_Shift_Longitude</b></td>
				<td>ST_Shift_Longitude( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by translating any negative longitude by 360.<hr>
				Only meaningful for geographic (longitude/latitude) coordinates.<br>
                                Negative longitudes (-180/0) will be shifted by 360, thus allowing to represent longitudes in the 0/360 range and effectively crossing the International Date Line. </td></tr>
			<tr><td><b>NormalizeLonLat</b></td>
				<td>NormalizeLonLat( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by normalizing any longitude in the range
                                [-180 / +180] and any latitude in the range [-90 / + 90].<hr>
				Only meaningful for geographic (longitude/latitude) coordinates.</td></tr>
			<tr><td><b>ScaleCoords</b><br><b>ScaleCoordinates</b></td>
				<td>ScaleCoords( geom <i>Geometry</i> , scaleX <i>Double precision</i> [ , scaleY <i>Double precision</i> ] ) : <i>Geometry</i><hr>
					ScaleCoordinates( geom <i>Geometry</i> , scaleX <i>Double precision</i> [ , scaleY <i>Double precision</i> ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by scaling coordinates according to scaleX and scaleY values<hr>
					if only one scale factor is specified, then an <i>isotropic</i> scaling occurs 
					[i.e. the same scale factor is applied to both axis]<br>
					otherwise an <i>anisotropic</i> scaling occurs [i.e. each axis is scaled according to its own scale factor]</td></tr>
			<tr><td><b>RotateCoords</b><br><b>RotateCoordinates</b></td>
				<td>RotateCoords( geom <i>Geometry</i> , angleInDegrees <i>Double precision</i> ) : <i>Geometry</i><hr>
					RotateCoordinates( geom <i>Geometry</i> , angleInDegrees <i>Double precision</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by rotating coordinates according to angleInDegrees value.<hr>
Positive angle = clockwise rotation.<br>
Negative angle = counterclockwise rotation.</td></tr>
			<tr><td><b>ReflectCoords</b><br><b>ReflectCoordinates</b></td>
				<td>ReflectCoords( geom <i>Geometry</i> , xAxis <i>Integer</i> , yAxis <i>Integer</i> ) : <i>Geometry</i><hr>
					ReflectCoordinates( geom <i>Geometry</i> , xAxis <i>Integer</i> , yAxis <i>Integer</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by reflecting coordinates according to xAxis and yAxis switches<hr>
					i.e. if xAxis is 0 (FALSE), then x-coordinates remains untouched; otherwise x-coordinates will be reflected</td></tr>
			<tr><td><b>SwapCoords</b><br><b>SwapCoordinates</b></td>
				<td>SwapCoords( geom <i>Geometry</i> ) : <i>Geometry</i><hr>
					SwapCoordinates( geom <i>Geometry</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by swapping x- and y-coordinates</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">	
				<h3><a name="p15plus">SQL functions supporting Affine Transformations and Ground Control Points</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>ATM_Create</b></td>
				<td>ATM_Create( <i>void</i> ) : <i>AffineMatrix</i><hr>
				ATM_Create( a <i>Integer</i> , b <i>Integer</i> , d <i>Integer</i> , e <i>Integer</i> , xoff <i>Integer</i> , yoff <i>Integer</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_Create( a <i>Integer</i> , b <i>Integer</i> , c <i>Integer</i> , d <i>Integer</i> , e <i>Integer</i>  , f <i>Integer</i> , 
				g <i>Integer</i> , h </>Integer</i> , i <i>Integer</i> , xoff <i>Integer</i> , yoff <i>Integer</i> , zoff <i>Integer</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix.
				<ul>
					<li>the first form (no arguments) will return an <b>Identity</b> matrix.</li>
					<li>the second and third forms will respectively return a fully initialized <b>2D</b> or <b>3D</b> Affine Transformation matrix.</li>
				</ul><hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_CreateTranslate</b></td>
				<td>ATM_CreateTranslate( tx <i>Double precision</i> , ty <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_CreateTranslate( tx <i>Double precision</i> , ty <i>Double precision</i> , tz <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing a <b>2D</b> or <b>3D Translate</b> transformation.</b><hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_CreateScale</b></td>
				<td>ATM_CreateScale( sx <i>Double precision</i> , sy <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_CreateScale( sx <i>Double precision</i> , sy <i>Double precision</i> , sz <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing a <b>2D</b> or <b>3D Scale</b> transformation.</b><hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_CreateRotate</b></td>
				<td>ATM_CreateRotate( angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_CreateZRoll( angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing a <b>Rotate</b> transformation (along the <b>Z axis</b>).</b><hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_CreateXRoll</b></td>
				<td>ATM_CreateXRoll( angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing a <b>Rotate</b> transformation (along the <b>X axis</b>).</b><hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_CreateYRoll</b></td>
				<td>ATM_CreateYRoll( angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing a <b>Rotate</b> transformation (along the <b>Y axis</b>).</b><hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_Multiply</b></td>
				<td>ATM_Multiply( matrixA <i>AffineMatrix</i> , matrixB <i>AffineMatrix</i> ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix representing the result of multiplying <b>matrixA</b> by <b>matrixB</b>.<hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_Translate</b></td>
				<td>ATM_Translate( matrix <i>AffineMatrix</i> , tx <i>Double precision</i> , ty <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_CreateTranslate( matrix <i>AffineMatrix</i> , tx <i>Double precision</i> , ty <i>Double precision</i> , tz <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix by chaining a further <b>2D</b> or <b>3D Translate</b> to a previous transformation matrix.</b><hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_Scale</b></td>
				<td>ATM_Scale( matrix <i>AffineMatrix</i> , sx <i>Double precision</i> , sy <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_Scale( matrix <i>AffineMatrix</i> , sx <i>Double precision</i> , sy <i>Double precision</i> , sz <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix by chaining a further <b>2D</b> or <b>3D Scale</b> to a previous transformation matrix.</b><hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>ATM_Rotate</b></td>
				<td>ATM_Rotate( matrix <i>AffineMatrix</i> , angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i><hr>
				ATM_ZRoll( matrix <i>AffineMatrix</i> , angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix by chaining a further <b>Rotate</b> (along the <b>Z axis</b>) to a previous transformation matrix.</b><hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_XRoll</b></td>
				<td>ATM_XRoll( matrix <i>AffineMatrix</i> , angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix by chaining a further <b>Rotate</b> (along the <b>X axis</b>) to a previous transformation matrix.</b><hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_YRoll</b></td>
				<td>ATM_YRoll( matrix <i>AffineMatrix</i> , angleInDegrees <i>Double precision</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a BLOB-encoded Affine Transformation matrix by chaining a further <b>Rotate</b> (along the <b>Y axis</b>) to a previous transformation matrix.</b><hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_Determinant</b></td>
				<td>ATM_Determinant( matrix <i>AffineMatrix</i> ] ) : <i>Double precision</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return the Determinant from an Affine Transformation matrix.<hr>
				will return <b>0.0</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_IsInvertible</b></td>
				<td>ATM_IsInvertible( matrix <i>AffineMatrix</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return <b>1</b> if the Affine Transformation matrix can be inverted, <b>0</b> if not.<hr>
				will return <b>-1</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_Invert</b></td>
				<td>ATM_Invert( matrix <i>AffineMatrix</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return an inverted Affine Transformation matrix.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_IsValid</b></td>
				<td>ATM_IsValid( matrix <i>AffineMatrix</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return <b>1</b> if the BLOB argument really contains a valid Affine Transformation matrix, <b>0</b> if not.<hr>
				will return <b>-1</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_AsText</b></td>
				<td>ATM_AsText( matrix <i>AffineMatrix</i> ] ) : <i>Text</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a serialized text string corresponding to an Affine Transformation matrix.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>ATM_Transform</b></td>
				<td>ATM_Transform( geom <i>Geometry</i> , matrix <i>AffineMatrix</i> [ , newSRID <i>Integer</i> ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>return a geometric object obtained by applying an Affine Transformation; if the optional arg newSRID is defined then the returned Geometry will assume the corresponding 
				Reference System, otherwise it will preserve the same Reference System of the input Geometry.<hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td><b>GCP_Compute</b></td>
				<td>GCP_Compute( pointA <i>Geometry</i> , pointB <i>Geometry</i> [ order <i>Integer</i>] ) : <i>PolynomialCoeffs</i></td>
				<td></td>
				<td align="center" bgcolor="#90f0d0">GrassGis code<br>GPLv2+</td>
				<td>return BLOB-encoded objects containing Polynomial coefficients computed from a set of matching <b>Ground Control Points</b> pairs.
				<ul>
					<li><b>pointA</b> corresponds to the origin Reference System; <b>pointB</b> corresponds to the destination target.</li>
					<li>the input Geometries must be of the <b>Point</b> type and must have the same dimensions</li>
					<li>if the points have <b>XYZ</b> or <b>XYZM</b> dimensions then <b>3D coeffs</b> will be returned, otherwise <b>2D</b> coeffs will be return.</li>
					<li>the optional <b>order</b> argument can assume the following values:
					<ul>
						<li><b>0</b>: a set of <b>2D coeffs</b> will be returned by applying the <b>Thin Plate Spline</b> method.</li>
						<li><b>1</b>: (<i>default setting</i>) a set of <b>2D</b> or <b>3D</b> Polynomial coeffs</b> of the <b>1st order</b> will be returned.</li>
						<li><b>2</b>: a set of <b>2D</b> or <b>3D</b> Polynomial coeffs</b> of the <b>2nd order</b> will be returned.</li>
						<li><b>3</b>: a set of <b>2D</b> or <b>3D</b> Polynomial coeffs</b> of the <b>3rd order</b> will be returned.</li>
					</ul></li>
				</ul><hr>
				will return <b>NULL</b> on invalid arguments<hr>
				<u><b>aggreagate function</b></u></td></tr>
			<tr><td><b>GCP_IsValid</b></td>
				<td>GCP_IsValid( matrix <i>PolynomialCoeffs</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#90f0d0">GrassGis code<br>GPLv2+</td>
				<td>return <b>1</b> if the BLOB argument really contains valid Polynomial coeffs, <b>0</b> if not.<hr>
				will return <b>-1</b> on invalid argument.</td></tr>
			<tr><td><b>GCP_AsText</b></td>
				<td>GCP_AsText( matrix <i>PolynomialCoeffs</i> ] ) : <i>Text</i></td>
				<td></td>
				<td align="center" bgcolor="#90f0d0">GrassGis code<br>GPLv2+</td>
				<td>return a serialized text string corresponding to the Polynomial coeffs.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>GCP2ATM</b></td>
				<td>GCP2ATM( matrix <i>PolynomialCoeffs</i> ] ) : <i>AffineMatrix</i></td>
				<td></td>
				<td align="center" bgcolor="#90f0d0">GrassGis code<br>GPLv2+</td>
				<td>return an Affine Transformation matrix corresponding to the Polynomial coeffs.<br>
				Only a set of Polynomial coeffs of the <b>1st order</b> can be converted to an Affine Transformation matrix.<hr>
				will return <b>NULL</b> on invalid argument.</td></tr>
			<tr><td><b>GCP_Transform</b></td>
				<td>GCP_Transform( geom <i>Geometry</i> , coeffs <i>PolynomialCoeffs</i> [ , newSRID <i>Integer</i> ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#90f0d0">GrassGis code<br>GPLv2+</td>
				<td>return a geometric object obtained by applying a Transformation based on Polynomial coefficients of the <b>1st</b>, <b>2nd</b> or <b>3rd order</b>; if the optional arg newSRID is defined then the returned Geometry will assume the corresponding 
				Reference System, otherwise it will preserve the same Reference System of the input Geometry.<hr>
				will return <b>NULL</b> on invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16">SQL functions for Spatial-MetaData and Spatial-Index handling</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>InitSpatialMetaData</b></td>
				<td>InitSpatialMetaData( void ) : <i>Integer</i><hr>
					InitSpatialMetaData( transaction <i>Integer</i> ) : <i>Integer</i><hr>
					InitSpatialMetaData( mode <i>String</i> ) : <i>Integer</i><hr>
					InitSpatialMetaData( transaction <i>Integer</i> , mode <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates the <b>geometry_columns</b> and <b>spatial_ref_sys</b> metadata tables<br>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE
<ul>
	<li>if the <i>optional</i> argument <b>transaction</b> is set to <b>TRUE</b> the whole operation will be handled as a single <i>Transaction</i> (faster): the default setting is <b>transaction=FALSE</b> (slower, but safer).</li>
	<li>if the <i>optional</i> argument <b>mode</b> is not specified then any possible ESPG SRID definition will be inserted into the <b>spatial_ref_sys</b> table.</li>
	<li>if the <b>mode</b> arg <b>'WGS84'</b> (alias <b>'WGS84_ONLY'</b>) is specified, then only WGS84-related EPSG SRIDs will be inserted</li>
	<li>if the <b>mode</b> arg <b>'NONE'</b> (alias <b>'EMPTY'</b>) is specified, no EPSG SRID will be inserted at all</li>
</ul></td></tr>
			<tr><td><b>InsertEpsgSrid</b></td>
				<td>InsertEpsgSrid( srid <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Attempts to insert into <b>spatial_ref_sys</b> the EPSG definition uniquely identified by <b>srid</b><br>
				[the corresponding EPSG SRID definition will be copied from the inlined dataset defined in <b>libspatialite</b>]<hr>
the return type is Integer, with a return value of 1 for success or 0 for failure</td></tr>
			<tr><td><b>AddGeometryColumn</b></td>
				<td>AddGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> ,
geom_type <i>String</i> [ , dimension <i>String</i> [ , not_null <i>Integer</i> ] ] ) : <i>Integer</i></td>
				<td align="center" bgcolor="#d0f0d0">X</td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates a new <u>geometry column</u> updating the Spatial Metadata tables and creating any
required <u>trigger</u> in order to enforce constraints<hr>
				<b>geom_type</b> has to be one of the followings:<ul>
				<li>'POINT', 'POINTZ', 'POINTM', 'POINTZM'</li>
				<li>'LINESTRING', 'LINESTRINGZ', 'LINESTRINGM', 'LINESTRINGZM'</li>
				<li>'POLYGON', 'POLYGONZ', 'POLYGONM', 'POLYGONZM'</li>
				<li>'MULTIPOINT', 'MULTIPOINTZ', 'MULTIPOINTM', 'MULTIPOINTZM'</li>
				<li>'MULTILINESTRING', 'MULTILINESTRINGZ', 'MULTILINESTRINGM', 'MULTILINESTRINGZM'</li>
				<li>'MULTIPOLYGON', 'MULTIPOLYGONZ', 'MULTIPOLYGONM', 'MULTIPOLYGONZM'</li>
				<li>'GEOMETRYCOLLECTION', 'GEOMETRYCOLLECTIONZ', 'GEOMETRYCOLLECTIONZM', 'GEOMETRYCOLLECTIONZM'</li>
				<li>'GEOMETRY', 'GEOMETRYZ', 'GEOMETRYM', 'GEOMETRYZM'</li>
				</ul><b>dimension</b> has to be one of the followings:
				<ul>
				<li><b>'XY'</b> or <b>2</b>: 2D points, identified by <b>X</b> and <b>Y</b> coordinates</li>
				<li><b>'XYM'</b>: 2D points, identified by <b>X</b> and <b>Y</b> coordinates. 
				Each point stores an <b>M</b>-value (<i>measure</i>) as well</li>
				<li><b>'XYZ'</b> or <b>3</b>: 3D points, identified by <b>X</b>, <b>Y</b> and <b>Z</b> coordinates</li>
				<li><b>'XYZM'</b> or <b>4</b>: 3D points, identified by <b>X</b>, <b>Y</b> and <b>Z</b> coordinates. 
				Each point stores an <b>M</b>-value (<i>measure</i>) as well</li>
				</ul>
                                Please note: the <b>dimension</b> argument is optional; anyway, if specified, iy's expected to be consistent with the declared <b>geom_type</b><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<hr>
the optional 6th arg [<b>not_null</b>] is a non-standard extension required by the peculiar SQLite arch:<ul>
				<li>if set to <b>0</b> [<i>false</i>], then the Geometry column will accept NULL values as well.
					This is the <u>default</u> behaviour</li>
				<li>if set to any <b>&lt;&gt; 0 value</b> [<i>true</i>], then the Geometry will be defined using a <b>NOT NULL</b> clause</li>
				</ul></td></tr>
			<tr><td><b>RecoverGeometryColumn</b></td>
				<td>RecoverGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> ,
geom_type <i>String</i> [ , dimension <i>Integer</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Validates an existing ordinary column in order to possibly transform it in a real <u>geometry column</u>,
thus updating the Spatial Metadata tables and creating any required <u>trigger</u> in order to enforce constraints<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>DiscardGeometryColumn</b></td>
				<td>DiscardGeometryColumn( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Removes a <u>geometry column</u> from Spatial MetaData tables and drops any related <u>trigger</u><br>
the column itself still continues to exist untouched as an ordinary, unconstrained column<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>RegisterVirtualGeometry</b></td>
				<td>RegisterVirtualGeometry( table <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Registers a <u>VirtualShape</u> table into Spatial MetaData tables; the VirtualShape table should be previously created by invoking <b>CREATE VIRTUAL TABLE ... USING VirtualShape(...)</b><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>DropVirtualGeometry</b></td>
				<td>DropVirtualGeometry( table <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Removes a <u>VirtualShape</u> table from Spatial MetaData tables, dropping the VirtualShape table as well.<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>CreateSpatialIndex</b></td>
				<td>CreateSpatialIndex( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Builds an RTree <b>Spatial Index</b> on a <u>geometry column</u>, creating any required <u>trigger</u>
required in order to enforce full data coherency between the main table and Spatial Index<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<hr>
-1 will be returned if any physical column named "rowid" (caseless) shadowing the real ROWID is detected.</td></tr>
			<tr><td><b>CreateMbrCache</b></td>
				<td>CreateMbrCache( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Builds an <b>MbrCache</b> on a <u>geometry column</u>, creating any required <u>trigger</u>
required in order to enforce full data coherency between the main table and the MbrCache<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>DisableSpatialIndex</b></td>
				<td>DisableSpatialIndex( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Disables an RTree <b>Spatial Index</b> or <b>MbrCache</b>, removing any related <u>trigger</u><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
		<tr><td><b>CheckShadowedRowid</b></td>
				<td>CheckShadowedRowid( table <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Checks if some table has a physical column named "rowid" (caseless) shadowing the real ROWID.<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<br>
NULL will be returned if the requested table doesn't exist.</td></tr>
		<tr><td><b>CheckWithoutRowid</b></td>
				<td>CheckWithoutRowid( table <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Checks if some table was created by specifying a <b>WITHOUT ROWID</b> clause.<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<br>
NULL will be returned if the requested table doesn't exist.</td></tr>
		<tr><td><b>CheckSpatialIndex</b></td>
				<td>CheckSpatialIndex( void ) : <i>Integer</i><hr>
					CheckSpatialIndex( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Checks an RTree <b>Spatial Index</b> for validity and consistency
				<ul>
					<li>if no arguments are passed, then any RTree defined into <b>geometry_columns</b> will be checked</li>
					<li>otherwise only the RTree corresponding to <b>table</b> and <b>column</b> will be checked</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<br>
NULL will be returned if the requested RTree doesn't exist<hr>
-1 will be returned if any physical column named "rowid" (caseless) shadowing the real ROWID is detected.</td></tr>
		<tr><td><b>RecoverSpatialIndex</b></td>
				<td>RecoverSpatialIndex( [ no_check : <i>Integer</i> ] ) : <i>Integer</i><hr>
					RecoverSpatialIndex( table <i>String</i> , column <i>String</i> [ , no_check : <i>Integer</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Recovers a (<i>possibly broken</i>) RTree <b>Spatial Index</b>
				<ul>
					<li>if no arguments are passed, then any RTree defined into <b>geometry_columns</b> will be recovered</li>
					<li>otherwise only the RTree corresponding to <b>table</b> and <b>column</b> will be recovered</li>
					<li>the <i>optional</i> argument <b>no_check</b> will be interpreted as follows:
						<ul>
							<li>if <b>no_check = FALSE</b> (<i>default</i>) the RTree will be checked first:
								and only an invalid RTree will be then actually rebuilt</li>
							<li>if <b>no_check = TRUE</b> the RTree will be unconditionally rebuilt from scratch</li>
						</ul></li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<br>
NULL will be returned if the requested RTree doesn't exist<hr>
-1 will be returned if any physical column named "rowid" (caseless) shadowing the real ROWID is detected.</td></tr>
		<tr><td><b>InvalidateLayerStatistics</b></td>
				<td>InvalidateLayerStatistics( [ void ) : <i>Integer</i><hr>
					InvalidateLayerStatistics( table <i>String</i> [ , column <i>String</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Immediately and unconditionally invalidates the internal Layer Statistics<ul>
					<li>if no arguments are passed, then internal statistics will be invalidated 
						for any possible Geometry Column defined in the current DB</li>
					<li>otherwise statistics will be updated only for Geometry Columns
						corresponding to the given table</li>
					</ul><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<hr>
				<u>Please note</u>: will effectively work only on behalf DB-files supporting the more recent metatables layout introduced 
				starting since version <b>4.x</b>; in any other case will always return an error and no action will happen.</td></tr>
		<tr><td><b>UpdateLayerStatistics</b></td>
				<td>UpdateLayerStatistics( [ void ) : <i>Integer</i><hr>
					UpdateLayerStatistics( table <i>String</i> [ , column <i>String</i> ] ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Updates the internal Layer Statistics [Feature Count and Total Extent]<ul>
					<li>if no arguments are passed, then internal statistics will be updated 
						for any possible Geometry Column defined in the current DB</li>
					<li>otherwise statistics will be updated only for Geometry Columns
						corresponding to the given table</li>
					</ul><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
		<tr><td><b>GetLayerExtent</b></td>
				<td>GetLayerExtent( table <i>String</i> [ , column <i>String</i> [ , mode <i>Boolean</i>] ] ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Return the Envelope corresponding to the Total Extent (<i>bounding box</i>] of some Layer;
                                    if the Table/Layer only contains a single Geometry column passing the column name isn't strictly required.<br>
                                    The returned extent will be retrieved from the Statistics tables:<ul>
					<li>if the third argument <b>mode</b> is set to TRUEa <b>PESSIMISTIC</b>
                                            strategy will be applied, i.e. an attempt will be made in order to update the Statistics tables before returning the Envelope.</li>
					<li>otherwise the returned Envelope will simply reflect the current values stored into the Statics tables as they are (<b>OPTIMISTIC</b> strategy, adopted by default).</li>
					</ul><hr>
                                        NULL will be returned if any error occurs or if the required table isn't a Layer.</td></tr>
		<tr><td><b>CreateTopologyTables</b></td>
				<td>CreateTopologyTables( SRID <i>Integer</i> , dims : <i>String</i> ) : <i>Integer</i><hr>
					CreateTopologyTables( prefix <i>String</i> , SRID <i>Integer</i> , dims : <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates a set of <b>Topology</b> tables
				<ul>
					<li><b>SRID</b> argument is mandatory</li>
					<li><b>dims</b> argument must be <b>'XY'</b> or <b>'XYZ'</b>:<br>
						<b>2</b> or <b>3</b> are valid aliases</li>
					<li>the <i>optional</i> argument <b>prefix</b> can be used to support more Topology sets on the same DB:<br>
						if omitted a <b>"topo_"</b> prefix will be assumed by default</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure)</td></tr>
		<tr><td><b>CreateRasterCoveragesTable</b></td>
				<td>CreateRasterCoveragesTable( <i>void</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates the <b>raster_coverages</b> table required by <b>RasterLite-2</b><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure)</td></tr>
		<tr><td><b>CreateVectorCoveragesTables</b></td>
				<td>CreateVectorCoveragesTables( <i>void</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates the <b>vector_coverages</b> and <b>vector_coverages_srid</b> tables required by <b>RasterLite-2</b><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure)</td></tr>
			<tr><td><b>RebuildGeometryTriggers</b></td>
				<td>RebuildGeometryTriggers( table_name <i>String</i> , geometry_column_name <i>String</i> ) : <i>integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This function will reinstall all geometry-related Triggers for the named table.<hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure)</td></tr>
			<tr><td><b>UpgradeGeometryTriggers</b></td>
				<td>UpgradeGeometryTriggers(  transaction <i>Integer</i>  ) : <i>integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This function will upgrade all geometry-related Triggers to the latest version 
				(all DB tables declaring at least one Geometry will be affected by the upgrade).<br>
				If the <b>transaction</b> argument is set to TRUE then the whole upgrade will be safely
				executed within an internally defined SQL transaction.<hr>
				<u>Please note</u>: DB-files created using obsolete versions of SpatiaLite (< 4.0.0) will not be upgraded.<hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure)</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16metacatalog">SQL functions supporting the MetaCatalog and related Statistics</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CreateMetaCatalogTables</b></td>
				<td>CreateMetaCatalogTables( transaction <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates both <b>splite_metacatalog</b> and <b>splite_metacatalog_statistics</b> tables;
                                <i>splite_metacatalog</i> will be populated so to describe every table/column currently defined within the DB.<br>
                                if the first argument <b>transaction</b> is set to <b>TRUE</b> the whole operation will be
                                handled as a single <i>Transaction</i> (faster): the default setting is <b>transaction=FALSE</b> (slower, but safer).<br>
                                the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>UpdateMetaCatalogStatistics</b></td>
				<td>UpdateMetaCatalogStatistics( transaction <i>Integer</i> , table_name <i>String</i> , column_name <i>String</i> ) : <i>Integer</i><hr>
                                UpdateMetaCatalogStatistics( transaction <i>Integer</i> , master_table <i>String</i> , table_name <i>String</i> , column_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Updates the <b>splite_metacatalog_statistics</b> table by computing the statistic summary for the required table/column.<br>
                                if the first argument <b>transaction</b> is set to <b>TRUE</b> the whole operation will be
                                handled as a single <i>Transaction</i> (faster): the default setting is <b>transaction=FALSE</b> (slower, but safer).<hr>
                                the first form (using <i>three</i> arguments) will simply attempt to update the statistic summary for a single 
                                table/column as identified by their names: a matching row is expected to be found in <i>splite_metacatalog</i>.<hr>
                                the second form (using <i>four</i> arguments) allows to update the statistic summary for many table/columns in a single pass.<br>
                                in this case <i>master_table</i> should identify an existing table: <i>table_name</i> and <i>column_name</i> should identify two columns belonging to this tables.<br>
                                the statistic summary for every table/columns fetched from the master table will then be updated:
                                any mismatching table/column will be simply ignored.<hr>
                                the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16style">SQL functions supporting SLD/SE Styled Layers</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
		<tr><td><b>CreateStylingTables</b></td>
				<td>CreateStylingTables() : <i>Integer</i><hr>
					CreateStylingTables( relaxed <i>Integer</i> ) : <i>Integer</i><hr>
					CreateStylingTables( relaxed <i>Integer</i> , transaction <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Creates a set of tables supporting <b>SLD/SE Styled Layers</b>.
				<ul>
					<li>if the <i>optional</i> argument <b>relaxed</b> is explicitly set as <b>TRUE</b> then
					a <i>relaxed</i> version of the validating Triggers will be installed (not checking for strict <i><u>XSD schema validation</u></i>).</li>
					<li>if the <i>optional</i> argument <b>transaction</b> is explicitly set as <b>TRUE</b> then 
					the whole operation will be atomically confined within a monolithic SQL transaction</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.<hr>
<i>Please note</i>: will implicitly invoke <b>CreateRasterCoverages()</b> if the <b>raster_coverages</b> table has not yet been created.</td></tr>
		<tr><td><b>SE_RegisterVectorCoverage</b></td>
				<td>SE_RegisterVectorCoverage( coverage_name <i>String</i> , f_table_name <i>String</i> , f_geometry_column <i>Sting</i> ) : <i>Integer</i><hr>
					SE_RegisterVectorCoverage( coverage_name <i>String</i> , f_table_name <i>String</i> , f_geometry_column <i>Sting</i> , title <i>String</i> , abstract <i>String </i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Creates a <b>Vector Coverage</b> based on an already existing Spatial Table.
				<ul>
					<li><b>coverage_name</b> is the symbolic name uniquely identifying each Vector Coverage (<i>Primary Key</i>).</li>
					<li><b>f_table_name</b> and <b>f_geometry_column</b> are expected to match a corresponding entry in the <b>geometry_columns</b> table.</li>
					<li>the optional arguments <b>title</b> and <b>abstract</b> could be eventually specified for better human readability.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterVectorCoverage</b></td>
				<td>SE_UnregisterVectorCoverage( coverage_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Completely removes an already defined <b>Vector Coverage</b> this including any furher depency; the underlying Spatial Table will be absolutely unaffected.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Coverage.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetVectorCoverageInfos</b></td>
				<td>SE_SetVectorCoverageInfos( coverage_name <i>String</i> , title <i>String</i> , abstract <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates the descriptive infos associated to a <b>Vector Coverage</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Coverage.</li>
					<li><b>title</b> and <b>abstract</b> represent the descriptive infos to be set.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterVectorCoverageSrid</b></td>
				<td>SE_RegisterVectorCoverageSrid( coverage_name <i>String</i> , srid <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Adds an alternative <b>SRID</b> to an already defined Vector Coverage.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Coverage.</li>
					<li><b>srid</b> is expected to match a corresponding entry in the <b>spatial_ref_sys</b> table.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterVectorCoverageSrid</b></td>
				<td>SE_UnregisterVectorCoverageSrid( coverage_name <i>String</i> , srid <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already defined alternative <b>SRID</b> from a Vector Coverage.
				<ul>
					<li><b>coverage_name</b> and <b>srid</b> must identify some previously defined alternative SRID.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UpdateVectorCoverageExtent</b></td>
				<td>SE_UpdateVectorCoverageExtent() : <i>Integer</i><hr>
				    SE_UpdateVectorCoverageExtent( transaction <i>Integer</i> ) : <i>Integer</i><hr>
				    SE_UpdateVectorCoverageExtent( coverage_name <i>String</i> ) : <i>Integer</i><hr>
				    SE_UpdateVectorCoverageExtent( coverage_name <i>String</i> , transaction <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates the <b>Extent</b> boundary supporting a Vector Coverage, this including any eventually defined alternative SRID.
				<ul>
					<li>if the optional <b>coverage_name</b> argument is set then only that single Vector Coverage will be updated; 
					otherwise all registered Vector Coverages will be processed in a single pass (may require a long time).</li>
					<li>if the optional <b>transaction</b> argument is set to <b>TRUE</b> then the whole operation will be internally
					handled as a single SQL Transaction.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterVectorCoverageKeyword</b></td>
				<td>SE_RegisterVectorCoverageeKeyword( coverage_name <i>String</i> , keyword <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Adds a <b>keyword</b> to an already defined Vector Coverage.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Coverage.</li>
					<li><b>keyword</b> must not be already defined for the same Coverage.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterVectorCoverageKeyword</b></td>
				<td>SE_UnregisterVectorCoverageKeyword( coverage_name <i>String</i> , keyword <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already defined <b>keyword</b> from a Vector Coverage.
				<ul>
					<li><b>coverage_name</b> and <b>keyword</b> must identify some previously defined keyword.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterExternalGraphic</b></td>
				<td>SE_RegisterExternalGraphic( xlink_href <i>String</i> , resource <i>BLOB</i> ) : <i>Integer</i><hr>
					SE_RegisterExternalGraphic( xlink_href <i>String</i> , resource <i>BLOB</i> , title <i>String</i> , abstract <i>String</i> , file_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts (or updates) an <b>External Graphic Resource</b>.
				<ul>
					<li><b>xlink_href</b> uniquely identifies each Resource (<i>Primary Key</i>).</li>
					<li><b>resource</b> is expected to be a BLOB containing an <i>image/gif</i>, <i>image/png</i>, <i>image/jpeg</i> or <i>image/svg+xml</i> payload.</li>
					<li>the optional arguments <b>title</b>, <b>abstract</b> and <b>file_name</b> could be eventually specified for better human readability.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterExternalGraphic</b></td>
				<td>SE_UnregisterExternalGraphic( xlink_href <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Deletes an already existing <b>External Graphic Resource</b>.
				<ul>
					<li><b>xlink_href</b> the External Resource to be deleted.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterVectorStyle</b></td>
				<td>SE_RegisterVectorStyle( style <i>BLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts a new <b>Vector Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD/SE Style of the Vector type.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The registered Style will be identified either by its unique <b>Style ID</b> or by its <b>Style Name</b> automatically retrieved from SLD/SE XML.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterVectorStyle</b></td>
				<td>SE_UnregisterVectorStyle( style_id <i>Integer</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</i><hr>
					SE_UnregisterVectorStyle( style_name <i>Text</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already registered <b>Vector Style</b> definition.
				<ul>
					<li>The Style to be removed could be referenced either by its unique <b>Style Id</b> or by its <b>Style Name</b>.<br>
					Anyway any attempt to remove a Style identified by its <b>Name</b> will be rejected if the if two (or more) Styles share the same <b>Name</b> thus causing ambiguity.</li>
					<li>when the <i>optional</i> argument <b>remove_all</b> is explicitly set to <b>TRUE</b> the Style will be removed even if it's already referenced by some
					<b>VectorStyledLayer</b> and all dependings references will be removed at the same time.<br>
					In any other case any attempt to unregister a Style already referenced by one (or more) <b>VectorStyleLayer</b> will be rejected.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_ReloadVectorStyle</b></td>
				<td>SE_ReloadVectorStyle( style_id <i>Integer</i> , style <i>BLOB</i> ) : <i>Integer</i><hr>
					SE_ReloadVectorStyle( style_name <i>Text</i> , style <i>BLOB</i> ) : <i>Integer</td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates an already existing <b>Vector Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD/SE Style of the Vector type.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The updated Style will continue to be identified by its current unique <b>Style ID</b> but the <b>Style Name</b> will be automatically updated accordingly to SLD/SE XML.</li></li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterVectorStyledLayer</b></td>
				<td>SE_RegisterVectorStyledLayer( coverage_name <i>String</i> , style_id <i>Integer</i> ) : <i>Integer</i><hr>
					SE_RegisterVectorStyledLayer( coverage_name <i>String</i> , style_name <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Associates a <b>Vector Style</b> to a <b>Vector Styled Layer</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Layer.</li>
					<li>An already registered Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterVectorStyledLayer</b></td>
				<td>SE_UnregisterVectorStyledLayer( coverage_name <i>String</i> , style_id <i>Integer</i> ) : <i>Integer</i><hr>
					SE_UnregisterVectorStyledLayer( coverage_name <i>String</i> , style_name <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an association between a <b>Vector Style</b> and a <b>Vector Styled Layer</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Vector Layer.</li>
					<li>An already associated Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterRasterStyle</b></td>
				<td>SE_RegisterRasterStyle( style <i>BLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts a new <b>Raster Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD/SE Style of the Raster type.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The registered Style will be identified either by its unique <b>Style ID</b> or by its <b>Style Name</b> automatically retrieved from SLD/SE XML.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterRasterStyle</b></td>
				<td>SE_UnregisterRasterStyle( style_id <i>Integer</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</i><hr>
					SE_UnregisterRasterStyle( style_name <i>Text</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already registered <b>Raster Style</b> definition.
				<ul>
					<li>The Style to be removed could be referenced either by its unique <b>Style Id</b> or by its <b>Style Name</b>.<br>
					Anyway any attempt to remove a Style identified by its <b>Name</b> will be rejected if the if two (or more) Styles share the same <b>Name</b> thus causing ambiguity.</li>
					<li>when the <i>optional</i> argument <b>remove_all</b> is explicitly set to <b>TRUE</b> the Style will be removed even if it's already referenced by some
					<b>RasterStyledLayer</b> and all dependings references will be removed at the same time.<br>
					In any other case any attempt to unregister a Style already referenced by one (or more) <b>RasterStyleLayer</b> will be rejected.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_ReloadRasterStyle</b></td>
				<td>SE_ReloadRasterStyle( style_id <i>Integer</i> , style <i>BLOB</i> ) : <i>Integer</i><hr>
					SE_ReloadRasterStyle( style_name <i>Text</i> , style <i>BLOB</i> ) : <i>Integer</td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates an already existing <b>Raster Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD/SE Style of the Raster type.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The updated Style will continue to be identified by its current unique <b>Style ID</b> but the <b>Style Name</b> will be automatically updated accordingly to SLD/SE XML.</li><
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterRasterStyledLayer</b></td>
				<td>SE_RegisterRasterStyledLayer( coverage_name <i>String</i> , style_id <i>Integer</i>  ) : <i>Integer</i><hr>
					SE_RegisterRasterStyledLayer( coverage_name <i>String</i> , style_name <i>Text</i>  ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Associates a <b>Raster Style</b> to a <b>Raster Styled Layer</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Raster Layer.</li>
					<li>An already registered Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterRasterStyledLayer</b></td>
				<td>SE_UnregisterRasterStyledLayer( coverage_name <i>String</i> , style_id <i>Integer</i> ) : <i>Integer</i><hr>
					SE_UnregisterRasterStyledLayer( coverage_name <i>String</i> , style_name <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an association between a <b>Raster Style</b> and a <b>Raster Styled Layer</b>.
				<ul>
					<li><b>coverage_name</b> must identify an existing Raster Layer.</li>
					<li>An already associated Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterRasterCoverageSrid</b></td>
				<td>SE_RegisterRasterCoverageSrid( coverage_name <i>String</i> , srid <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Adds an alternative <b>SRID</b> to an already defined Raster Coverage.
				<ul>
					<li><b>coverage_name</b> must identify an existing Raster Coverage.</li>
					<li><b>srid</b> is expected to match a corresponding entry in the <b>spatial_ref_sys</b> table.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterRasterCoverageSrid</b></td>
				<td>SE_UnregisterRasterCoverageSrid( coverage_name <i>String</i> , srid <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already defined alternative <b>SRID</b> from a Raster Coverage.
				<ul>
					<li><b>coverage_name</b> and <b>srid</b> must identify some previously defined alternative SRID.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UpdateRasterCoverageExtent</b></td>
				<td>SE_UpdateRasterCoverageExtent() : <i>Integer</i><hr>
				    SE_UpdateRasterCoverageExtent( transaction <i>Integer</i> ) : <i>Integer</i><hr>
				    SE_UpdateRasterCoverageExtent( coverage_name <i>String</i> ) : <i>Integer</i><hr>
				    SE_UpdateRasterCoverageExtent( coverage_name <i>String</i> , transaction <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates the <b>Extent</b> boundary supporting a Raster Coverage, this including any eventually defined alternative SRID.
				<ul>
					<li>if the optional <b>coverage_name</b> argument is set then only that single Raster Coverage will be updated; 
					otherwise all registered Raster Coverages will be processed in a single pass (may require a long time).</li>
					<li>if the optional <b>transaction</b> argument is set to <b>TRUE</b> then the whole operation will be internally
					handled as a single SQL Transaction.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterRasterCoverageKeyword</b></td>
				<td>SE_RegisterRasterCoverageKeyword( coverage_name <i>String</i> , keyword <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Adds a <b>keyword</b> to an already defined Raster Coverage.
				<ul>
					<li><b>coverage_name</b> must identify an existing Raster Coverage.</li>
					<li><b>keyword</b> must not be already defined for the same Coverage.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterRasterCoverageKeyword</b></td>
				<td>SE_UnregisterRasterCoverageKeyword( coverage_name <i>String</i> , keyword <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already defined <b>keyword</b> from a Raster Coverage.
				<ul>
					<li><b>coverage_name</b> and <b>keyword</b> must identify some previously defined keyword.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetStyledGroupInfos</b></td>
				<td>SE_SetStyledGroupInfos( group_name <i>String</i> , title <i>String</i> , abstract <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts (or updates) the descriptive infos associated to a <b>Styled Group</b>.
				<ul>
					<li><b>group_name</b> must identify a Styled Group: if the Styled Group doesn't yet exists it will be implicitly created.</li>
					<li><b>title</b> and <b>abstract</b> represent the descriptive infos to be set.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterStyledGroup</b></td>
				<td>SE_UnregisterStyledGroup( group_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Completely removes a <b>Styled Group</b> and any related item.
				<ul>
					<li><b>group_name</b> must identify an existing Styled Group.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterStyledGroupVector</b></td>
				<td>SE_RegisterStyledGroupVector( group_name <i>String</i> , coverage_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Registers a <b>Vector</b> Layer within a <b>Styled Group</b>.
				<ul>
					<li><b>group_name</b> must identify a Styled Group: if the Styled Group doesn't yet exists it will be implicitly created.</li>
					<li><b>coverage_name</b> must identify an existing Vector Layer.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterStyledGroupRaster</b></td>
				<td>SE_RegisterStyledGroupRaster( group_name <i>String</i> , coverage_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Registers a <b>Raster</b> Layer within a <b>Styled Group</b>.
				<ul>
					<li><b>group_name</b> must identify a Styled Group: if the Styled Group doesn't yet exists it will be implicitly created.</li>
					<li><b>coverage_name</b> must identify an existing Raster Layer.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetStyledGroupLayerPaintOrder</b></td>
				<td>SE_SetStyledGroupLayerPaintOrder( item_id <i>Integer</i> , paint_order <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Explictly assigns the <b>paint_order</b> for a <b>Raster</b> or <b>Vector</b> Layer within a <b>Styled Group</b>.
				<ul>
					<li>If <b>paint_order</b> is a negative value then the next available order position will be automatically assigned (<i>top level</i>).<br>
					<u>Please note</u>: the painting order will always follow the Painter rule, i.e. a lower paint-order value will always be painted before painting any higher value. </li>
					<li>An already defined Vector or Raster Layer Item within a Styled Group can always be referenced its unique <b>item_id</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetStyledGroupVectorPaintOrder</b></td>
				<td>SE_SetStyledGroupVectorPaintOrder( group_name <i>Text</i> , coverage_name <i>String</i> , paint_order <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Explictly assigns the <b>paint_order</b> for a <b>Vector</b> Layer within a <b>Styled Group</b>.
				<ul>
					<li>If <b>paint_order</b> is a negative value then the next available order position will be automatically assigned (<i>top level</i>).<br>
					<u>Please note</u>: the painting order will always follow the Painter rule, i.e. a lower paint-order value will always be painted before painting any higher value. </li>
					<li>An already defined Vector Layer Item can be safely referenced by its <b>Name</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_SetStyledGroupRasterPaintOrder</b></td>
				<td>SE_SetStyledGroupRasterPaintOrder( group_name <i>Text</i> , coverage_name <i>String</i> , paint_order <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Explictly assigns the <b>paint_order</b> for a <b>Raster</b> Layer within a <b>Styled Group</b>.
				<ul>
					<li>If <b>paint_order</b> is a negative value then the next available order position will be automatically assigned (<i>top level</i>).<br>
					<u>Please note</u>: the painting order will always follow the Painter rule, i.e. a lower paint-order value will always be painted before painting any higher value. </li>
					<li>An already defined Raster Layer Item can be safely referenced by its <b>Name</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterStyledGroupLayer</b></td>
				<td>SE_UnregisterStyledGroupLayer( item_id <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes a reference to a <b>Raster</b> or <b>Vector</b> Layer from within a <b>Styled Group</b>.
				<ul>
					<li>An already defined Vector or Raster Layer Item within a Styled Group can always be referenced its unique <b>item_id</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterStyledGroupVector</b></td>
				<td>SE_UnregisterStyledGroupVector( group_name <i>Text</i> , coverage_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes a reference to a <b>Vector</b> Layer from within a <b>Styled Group</b>.
				<ul>
					<li>An already defined Vector Layer Item can be safely referenced by its <b>Name</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterStyledGroupRaster</b></td>
				<td>SE_UnregisterStyledGroupRaster( group_name <i>Text</i> , coverage_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes a reference to a <b>Raster</b> Layer from within a <b>Styled Group</b>.
				<ul>
					<li>An already defined Raster Layer Item can be safely referenced by its <b>Name</b>.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterGroupStyle</b></td>
				<td>SE_RegisterGroupStyle( style <i>BLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts a new <b>Group Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD complex Style.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The registered Style will be identified either by its unique <b>Style ID</b> or by its unique <b>Style Name</b> automatically retrieved from SLD/SE XML.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterGroupStyle</b></td>
				<td>SE_UnregisterGroupStyle( style_id <i>Integer</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</i><hr>
					SE_UnregisterGroupStyle( style_name <i>Text</i> [ , remove_all <i>Integer</i> ] ) : <i>Integer</td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an already registered <b>Group Style</b> definition.
				<ul>
					<li>The Style to be removed could be referenced either by its unique <b>Style Id</b> or by its <b>Style Name</b>.<br>
					Anyway any attempt to remove a Style identified by its <b>Name</b> will be rejected if the if two (or more) Styles share the same <b>Name</b> thus causing ambiguity.</li>
					<li>when the <i>optional</i> argument <b>remove_all</b> is explicitly set to <b>TRUE</b> the Style will be removed even if it's already referenced by some
					<b>RasterStyledLayer</b> and all dependings references will be removed at the same time.<br>
					In any other case any attempt to unregister a Style already referenced by one (or more) <b>RasterStyleLayer</b> will be rejected.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_ReloadGroupStyle</b></td>
				<td>SE_ReloadGroupStyle( style_id <i>Integer</i> , style <i>BLOB</i> ) : <i>Integer</i><hr>
					SE_ReloadGroupStyle( style_name <i>Text</i> , style <i>BLOB</i> ) : <i>Integer</td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Updates an already existing <b>Group Style</b> definition.
				<ul>
					<li><b>style</b> is expected to be an XmlBLOB containing a valid SLD complex Style.<br>
					If <b>CreatedStylingTables()</b> was invoked without specifying the <i>relaxed</i> option this XmlBLOB is expected to have successfully passed a formal XML Schema Validation.<br>
					The updated Style will continue to be identified by its current unique <b>Style ID</b> but the <b>Style Name</b> will be automatically updated accordingly to SLD/SE XML.</li></li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_RegisterStyledGroupStyle</b></td>
				<td>SE_RegisterStyledGroupStyle( group_name <i>String</i> , style_id <i>Integer</i> ) : <i>Integer</i><hr>
					SE_RegisterStyledGroupStyle( group_name <i>String</i> , style_name <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Associates a <b>Group Style</b> to a <b>Styled Group</b>.
				<ul>
					<li><b>group_name</b> must identify an existing Styled Group.</li>
					<li>An already registered Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>SE_UnregisterStyledGroupStyle</b></td>
				<td>SE_UnregisterStyledGroupStyle( group_name <i>String</i> , style_id <i>Integer</i> ) : <i>Integer</i><hr>
					SE_UnregisterStyledGroupStyle( group_name <i>String</i> , style_name <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Removes an association between a <b>Group Style</b> and a <b>Styled Group</b>.
				<ul>
					<li><b>group_name</b> must identify an existing Styled Group.</li>
					<li>An already associated Style can be referenced either by its unique <b>Stile ID</b> or by its <b>Name</b>;
					anyway a reference <i>by Name</i> could eventually fail if the Name is ambiguous (duplicate).</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16isometa">SQL functions supporting ISO Metadata</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
		<tr><td><b>CreateIsoMetadataTables</b></td>
				<td>CreateIsoMetadataTables() : <i>Integer</i><hr>
					CreateIsoMetadataTables( relaxed <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Creates a set of tables supporting <b>ISO Metadata</b>.
				<ul>
					<li>if the <i>optional</i> argument <b>relaxed</b> is specified (any value), then
					a <i>relaxed</i> version of the validating Triggers will be installed.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>RegisterIsoMetadata</b></td>
				<td>RegisterIsoMetadata( scope <i>String</i> , metadata <i>BLOB</i> ) : <i>Integer</i><hr>
				RegisterIsoMetadata( scope <i>String</i> , metadata <i>BLOB</i> , id Integer ) : <i>Integer</i><hr>
				RegisterIsoMetadata( scope <i>String</i> , metadata <i>BLOB</i> , fileIdentifier <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Inserts (or updates) an <b>ISO Metadata</b> definition.
				<ul>
					<li><b>scope</b> can be one of <i>undefined</i>, <i>fieldSession</i>, <i>collectionSession</i>, 
					<i>series</i>, <i>dataset</i>, <i>featureType</i>, <i>feature</i>, <i>attributeType</i>, <i>attribute</i>, 
					<i>tile</i>, <i>model</i>, <i>catalogue</i>, <i>schema</i>, <i>taxonomy</i>, <i>software</i>,
					<i>service</i>, <i>collectionHardware</i>, <i>nonGeographicDataset</i>, <i>dimensionGroup</i>.</li>
					<li><b>metadata</b> is expected to be a valid XmlBLOB storing some IsoMetadata payload.</li>
					<li>the first form (two arguments only) always performs an <i>INSERT</i>; if one the optional arguments <b>id</b> or <b>fileIdentifier</b> an <i>UPDATE</i> could be eventually performed if a corresponding metadata row is already defined.</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE (success) or 0 for FALSE (failure): -1 will be
				returned on invalid arguments.</td></tr>
		<tr><td><b>GetIsoMetadataId</b></td>
				<td>GetIsoMetadataId( fileIdentifier <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Return the unique <b>id</b> corresponding to the <b>ISO Metadata</b> definition identified by <b>fileIdentifier</b>.<hr>
				If no corresponding ISO Metadata definition exists, this function will always return <i>ZERO</i>; <i>-1</i> will be returned for invalid arguments.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16fdo">SQL functions implementing FDO/OGR compatibility</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CheckSpatialMetaData</b></td>
				<td>CheckSpatialMetaData( void ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Checks the Spatial Metadata type, then returning:<ul>
				<li><b>0</b> - if the <b>geometry_columns</b> or <b>spatial_ref_sys</b> table does not exists, or if their actual layout doesn't corresponds to any known implementation</li>
				<li><b>1</b> - if both tables exist, and their layout is the one previously used by <b>SpatiaLite legacy</b> (<i>older versions including 3.1.0 any earlier</i>)</li>
				<li><b>2</b> - if both tables exist, and their layout is the one used by <b>FDO/OGR</b></li>
				<li><b>3</b> - if both tables exist, and their layout is the one currently used by <b>SpatiaLite</b> (<i>4.0.0 or any subsequent version</i>)</li>
				<li><b>4</b> - if the DB layout is the one defined by the <b>OGC GPKG</b> specification (<i>GeoPackage</i>)</li>
				</ul></td></tr>
			<tr><td><b>AutoFDOStart</b></td>
				<td>AutoFDOStart( void ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This function will inspect the Spatial Metadata, then automatically creating/refreshing a <b>VirtualFDO</b>
				wrapper for each FDO/OGR geometry table<hr>
the return type is Integer [how many VirtualFDO tables have been created]</td></tr>
			<tr><td><b>AutoFDOStop</b></td>
				<td>AutoFDOStop( void ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This function will inspect the Spatial Metadata, then automatically destroying any <b>VirtualFDO</b>
				wrapper found<hr>
the return type is Integer [how many VirtualFDO tables have been destroyed]</td></tr>
			<tr><td><b>InitFDOSpatialMetaData</b></td>
				<td>InitFDOSpatialMetaData( void ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates the <b>geometry_columns</b> and <b>spatial_ref_sys</b> metadata tables<br>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE<hr>
<u>Please note:</u> Spatial Metadata created using this function will have the FDO/OGR layout, and not the standard SpatiaLite layout</td></tr>
			<tr><td><b>AddFDOGeometryColumn</b></td>
				<td>AddFDOGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> ,
geom_type <i>Integer</i> , dimension <i>Integer</i>, geometry_format <i>String</i> ) : <i>Integer</i> </td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates a new <u>geometry column</u> updating the FDO/OGR Spatial Metadata tables<hr>
				<b>geom_type</b> has to be one of the followings:<ul>
				<li><b>1</b> <i>POINT</i></li>
				<li><b>2</b> <i>LINESTRING</i></li>
				<li><b>3</b> <i>POLYGON</i></li>
				<li><b>4</b> <i>MULTIPOINT</i></li>
				<li><b>5</b> <i>MULTILINESTRING</i></li>
				<li><b>6</b> <i>MULTIPOLYGON</i></li>
				<li><b>7</b> <i>GEOMETRYCOLLECTION</i></li>
				</ul><b>dimension</b> may be <b>2</b>, <b>3</b> or <b>4</b>, accordingly to OGR/FDO specs<br>
				<b>geometry_format</b> has to be one of the followings:<ul>
				<li>'WBT'</li>
				<li>'WKT'</li>
				<li>'FGF'</li>
				</ul><hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>RecoverFDOGeometryColumn</b></td>
				<td>RecoverFDOGeometryColumn( table <i>String</i> , column <i>String</i> , srid <i>Integer</i> ,
geom_type <i>String</i> , dimension <i>Integer</i>, geometry_format <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Validates an existing ordinary column in order to possibly transform it in a real <u>geometry column</u>,
thus updating the FDO/OGR Spatial Metadata tables<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td><b>DiscardFDOGeometryColumn</b></td>
				<td>DiscardFDOGeometryColumn( table <i>String</i> , column <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Removes a <u>geometry column</u> from FDO/OGR Spatial MetaData tables<br>
the column itself still continues to exist untouched as an ordinary column<hr>
the return type is Integer, with a return value of 1 for TRUE or 0 for FALSE</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p16gpkg">SQL functions implementing OGC GeoPackage compatibility</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>CheckGeoPackageMetaData</b></td>
				<td>CheckGeoPackageMetaData( void ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>This function will inspect the DB layout checking if it corresponds to the GPKG own style<hr>
the return type is Integer, with a return value of 1 for TRUE, 0 for FALSE</td></tr>
			<tr><td><b>AutoGPKGStart</b></td>
				<td>AutoGPKGStart( void ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will inspect the DB layout, then automatically creating/refreshing a <b>VirtualGPKG</b>
				wrapper for each GPKG geometry table<hr>
the return type is Integer [how many VirtualGPKG tables have been created]</td></tr>
			<tr><td><b>AutoGPKGStop</b></td>
				<td>AutoGPKGStop( void ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will inspect the DB layout, then automatically destroying any <b>VirtualGPKG</b>
				wrapper found<hr>
the return type is Integer [how many VirtualGPKG tables have been destroyed]</td></tr>
			<tr><td><b>gpkgCreateBaseTables</b></td>
				<td>gpkgCreateBaseTables( void ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create base tables for an "empty" GeoPackage<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgInsertEpsgSRID</b></td>
				<td>gpkgInsertEpsgSRID( srid <i>Integer</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will add a spatial reference system entry for the specified EPSG identifier;
				it is an error to try to add the entry if it already exists<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgCreateTilesTable</b></td>
				<td>gpkgCreateTilesTable( tile_table_name <i>String</i> , srid <i>Integer</i> , min_x <i>Double precision</i> ,
				min_y <i>Double precision</i> , max_x <i>Double precision</i> , max_y <i>Double precision</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create a new (empty) Tiles table and the triggers for that table;
				It also adds in the matching entries into gpkg_contents and gpkg_tile_matrix_set.<br>
				This function assumes usual tile conventions, including that the tiles are power-of-two-zoom.<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgCreateTilesZoomLevel</b></td>
				<td>gpkgCreateTilesZoomLevel( tile_table_name <i>String</i>, zoom_level <i>Integer</i> , extent_width <i>Double precision</i> ,
				extent_height <i>Double precision</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will add a zoom level for the specified table.<br>
				This function assumes usual tile conventions, including that the tiles are power-of-two-zoom,
				256x256 pixels, 1 tile at the top level (zoom level 0).<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgAddTileTriggers</b></td>
				<td>gpkgAddTileTriggers( tile_table_name <i>String</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will add Geopackage tile table triggers for the named table.<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgGetNormalZoom</b></td>
				<td>gpkgGetNormalZoom( tile_table_name <i>String</i> , inverted_zoom_level <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will return the normal integer zoom level for data stored in the specified table.<br>
				Note that this function can also be used to convert from a normal zoom level
				to an inverted zoom level - this conversion is symmetric.<hr>
				Raises a SQL exception if inverted zoom level is outside the range of
				tile_matrix_metadata table normal zoom levels defined for the tile_table</td></tr>
			<tr><td><b>gpkgGetNormalRow</b></td>
				<td>gpkgGetNormalRow( tile_table_name <i>String</i> , normal_zoom_level <i>Integer</i> , inverted_row_number <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will return the normal integer row number for the specified table, normal zoom level
				and inverted row number.<br>
				Note that this function can also be used to convert from a normal row number
				to an inverted row number - this conversion is symmetric.<hr>
				Raises a SQL exception if no zoom level row record in tile_matrix_metadata</td></tr>
			<tr><td><b>gpkgGetImageType</b></td>
				<td>gpkgGetImageType( image <i>Blob</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will return the image type (as a string) of the blob argument, or "unknown" if
				the image type is not one of the PNG, JPEG, TIFF or WebP format types that are supported in GeoPackage.
				The result will be one of:
				<ul>
				<li><b>"png"</b> for PNG</li>
				<li><b>"jpeg"</b> for JPEG</li>
				<li><b>"tiff"</b> for TIFF</li>
				<li><b>"x-webp"</b> for WebP</li>
				</ul>
				These are the mime type for the image format (without the "image/" prefix).<hr>
				This function raises exception on error (e.g. wrong argument type).</td></tr>
			<tr><td><b>gpkgAddGeometryColumn</b></td>
				<td>gpkgAddGeomtryColumn( table_name <i>Sting</i>, geometry_column_name <i>String</i> , geometry_type <i>String</i> , 
					with_z <i>Integer</i> , with_m <i>Integer</i> , srs_id <i>Integer</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>Adds a geometry column to the specified table:
				<ul>
					<li><b>geometry_type</b> is a normal WKT name:
						<ul>
							<li><b>"GEOMETRY"</b></li>
							<li><b>"POINT"</b></li>
							<li><b>"LINESTRING"</b></li>
							<li><b>"POLYGON"</b></li>
							<li><b>"MULTIPOINT"</b></li>
							<li><b>"MULTILINESTRING"</b></li>
							<li><b>"MULTIPOLYGON"</b></li>
							<li><b>"GEOMCOLLECTION"</b></li>
						</ul></li>
					<li><b>with_z</b> is a flag (0 for no z values, 1 for mandatory z values, 2 for optional z values)</li>
					<li><b>with_m</b> is a flag (0 for no m values, 1 for mandatory m values, 2 for optional m values)</li>
				</ul><hr>
				returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgAddGeometryTriggers</b></td>
				<td>gpkgAddGeometryTriggers( table_name <i>String</i> , geometry_column_name <i>String</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will add Geopackage geometry table triggers for the named table.<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgAddSpatialIndex</b></td>
				<td>gpkgAddSpatialIndex( table_name <i>String</i> , geometry_column_name <i>String</i> ) : <i>void</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will add Geopackage Spatial Index support for the named table.<hr>
returns nothing on success, raises exception on error</td></tr>
			<tr><td><b>gpkgMakePoint</b></td>
				<td>gpkgMakePoint (x <i>Double precision</i> , y <i>Double precision</i> ) : <i>GPKG Blob Geometry</i><hr>
				gpkgMakePoint (x <i>Double precision</i> , y <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG Blob Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create a GeoPackage geometry POINT.<hr>
				Raises a SQL exception on error</td></tr>
			<tr><td><b>gpkgMakePointZ</b></td>
				<td>gpkgMakePointZ (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> ) : <i>GPKG Blob Geometry</i><hr>
				gpkgMakePointZ (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG Blob Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create a GeoPackage geometry POINT Z.<hr>
				Raises a SQL exception on error</td></tr>
			<tr><td><b>gpkgMakePointM</b></td>
				<td>gpkgMakePointM (x <i>Double precision</i> , y <i>Double precision</i> , m <i>Double precision</i> ) : <i>GPKG Blob Geometry</i><hr>
				gpkgMakePointM (x <i>Double precision</i> , y <i>Double precision</i> , m <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG Blob Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create a GeoPackage geometry POINT M.<hr>
				Raises a SQL exception on error</td></tr>
			<tr><td><b>gpkgMakePointZM</b></td>
				<td>gpkgMakePointZM (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , m <i>Double precision</i> ) : <i>GPKG Blob Geometry</i><hr>
				gpkgMakePointZM (x <i>Double precision</i> , y <i>Double precision</i> , z <i>Double precision</i> , m <i>Double precision</i> , srid <i>Integer</i> ) : <i>GPKG Blob Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will create a GeoPackage geometry POINT ZM.<hr>
				Raises a SQL exception on error</td></tr>
			<tr><td><b>IsValidGPB</b></td>
				<td>IsValidGPB( geom <i>Blob</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will inspect a BLOB then checking if it really corresponds to a GPKG own Geometry<hr>
the return type is Integer, with a return value of 1 for TRUE, 0 for FALSE</td></tr>
			<tr><td><b>AsGPB</b></td>
				<td>AsGPB( geom <i>BLOB encoded geometry</i> ) : <i>GPKG Blob Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will convert a SpatiaLite geometry blob into a GeoPackage format geometry blob.<hr>
				Will return NULL if any error is encountered</td></tr>
			<tr><td><b>GeomFromGPB</b></td>
				<td>GeomFromGPB( geom <i>GPKG Blob Geometry</i> ) : <i>BLOB encoded geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will convert a GeoPackage format geometry blob into a SpatiaLite geometry blob.<hr>
				Will return NULL if any error is encountered</td></tr>
			<tr><td><b>CastAutomagic</b></td>
				<td>CastAutomagic( geom <i>Blob</i> ) : <i>BLOB encoded geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will indifferently accept on input:
				<ul>
					<li>a SpatiaLite own BLOB Geometry</li>
					<li>a GPKG own BLOB Geometry</li>
				</ul>
				then returning a SpatiaLite own BLOB geometry.<hr>
				Will return NULL if any error is encountered or on invalid / mismatching argument</td></tr>	
			<tr><td><b>GPKG_IsAssignable</b></td>
				<td>GPKG_IsAssignable( expected_type_name <i>String</i> , actual_type_name <i>String</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#d0f0ff">GeoPackage</td>
				<td>This function will check if <b>expected_type</b> is the same or is a super-type of <b>actual_type</b>;
				this function is required by the standard implementation of GPKG Geometry validation Triggers.<hr>
the return type is Integer, with a return value of 1 for TRUE, 0 for FALSE</td></tr>					
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p17">SQL functions for MbrCache-based queries</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>FilterMbrWithin</b></td>
				<td>FilterMbrWithin(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Retrieves from an MbrCache any entity whose MBR falls <u><i>within</i></u>
				the rectangle identified by extreme points <b>x1 y1</b> and <b>x2 y2</b></td></tr>
			<tr><td><b>FilterMbrContains</b></td>
				<td>FilterMbrContains(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Retrieves from an MbrCache any entity whose MBR <u><i>contains</i></u>
				the rectangle identified by extreme points <b>x1 y1</b> and <b>x2 y2</b></td></tr>
			<tr><td><b>FilterMbrIntersects</b></td>
				<td>FilterMbrIntersects(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Retrieves from an MbrCache any entity whose MBR <u><i>intersects</i></u>
				the rectangle identified by extreme points <b>x1 y1</b> and <b>x2 y2</b></td></tr>
			<tr><td><b>BuildMbrFilter</b></td>
				<td>BuildMbrFilter(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0f0d0">base</td>
				<td>Creates an MBR identified by extreme points <b>x1 y1</b> and <b>x2 y2</b><hr>
				This fuction is used internally by <u><i>triggers</i></u> related to MbrCache management,
				and is not intended for any other usage</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="p18">SQL functions for R*Tree-based queries (Geometry Callbacks)</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>RTreeIntersects</b></td>
				<td>RTreeIntersects(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0d0d0">geocallbacks</td>
				<td>Retrieves from an R*Tree Spatial Index any entity whose MBR <u><i>intersect</i></u>
				the rectangle identified by extreme points <b>x1 y1</b> and <b>x2 y2</b></td></tr>
			<tr><td><b>RTreeWithin</b></td>
				<td>RTreeWithin(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0d0d0">geocallbacks</td>
				<td><b>Deprecated function</b><br>
					Still maintained so to avoid backward compatibility issues, but now simply is an 
					<i>alias-name</i> for <b>RTreeIntersects</b></td></tr>
			<tr><td><b>RTreeContains</b></td>
				<td>RTreeContains(  x1 <i>Double precision</i> , y1 <i>Double precision</i> ,
				x2 <i>Double precision</i> , y2 <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0d0d0">geocallbacks</td>
				<td><b>Deprecated function</b><br>
					Still maintained so to avoid backward compatibility issues, but now simply is an 
					<i>alias-name</i> for <b>RTreeIntersects</b></td></tr>
			<tr><td><b>RTreeDistWithin</b></td>
				<td>RTreeDistWithin(  x <i>Double precision</i> , y <i>Double precision</i> ,
				radius <i>Double precision</i> )</td>
				<td></td>
				<td align="center" bgcolor="#d0d0d0">geocallbacks</td>
				<td>Retrieves from an R*Tree Spatial Index any entity whose MBR <u><i>intersect</i></u>
				the square circumscribed on the given circle (<b>x y</b> center, <b>radius)</b></td></tr>
            <tr><td colspan="5" align="center" bgcolor="#f0f0c0">
				<h3><a name="xmlBlob">SQL functions supporting XmlBLOB</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0">OGC<br>defined</th>
				<th bgcolor="#d0d0d0">required<br>module</th>
				<th bgcolor="#d0d0d0">Summary</th></tr>
			<tr><td><b>XB_Create</b></td>
				<td>XB_Create(  xmlPayload <i>BLOB</i> ) : <i>XmlBLOB</i><hr>
				XB_Create(  xmlPayload <i>BLOB</i> , compressed <i>Boolean</i> ) : <i>XmlBLOB</i><hr>
				XB_Create(  xmlPayload <i>BLOB</i> , compressed <i>Boolean</i> ,
				schemaURI <i>Text</i> ) : <i>XmlBLOB</i><hr>
				XB_Create(  xmlPayload <i>BLOB</i> , compressed <i>Boolean</i> ,
				internalSchemaURI <i>Boolean</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Construct an XmlBLOB object starting from an XmlDocument.<ul>
				<li>If <b>compressed</b> is set to TRUE the XmlBlob object will be compressed (default setting).</li>
                                <li>If <b>schemaURI</b> is specified then the XmlDocument will be validated against the given Schema (default setting is skipping any XML validation).</li>
                                <li>If <b>internalSchemaURI</b> is set (any value), then the XmlDocument will be validated againt the Schema URI internally defined within the XmlDocument itself (if any).</li></ul><hr>
				<b>NULL</b> will be returned for not well-formed XmlDocuments, or when XML validation is required but XmlDocument fails to pass validation for any reason.</td></tr>
			<tr><td><b>XB_GetPayload</b></td>
				<td>XB_GetPayload( xmlObject <i>XmlBLOB</i> [ , indent <i>Integer</i> ] ) : <i>BLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Extracts a generic BLOB from an XmlBLOB object, exactly corresponding to the original XmlDocument and fully preserving the original character encoding.<br>
				If the optional argument <b>indent</b> is set to some <i>positive</i> value then the returned XmlDocument
                                will be nicely formatted and properly indented by the required factor; <i>ZERO</i> will cause the whole 
                                XmlDocument to be returned as a single line. (default setting is <i>negative</i> indenting, i.e. not reformatting at all).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object).</td></tr>
			<tr><td><b>XB_GetDocument</b></td>
				<td>XB_GetDocument( xmlObject <i>XmlBLOB</i> [ , indent <i>Integer</i> ] ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Extracts an XmlDocument from an XmlBLOB object; the returned XmlDocument will always be UTF-8 encoded (<b>TEXT</b>), irrespectively from the original internal encoding declaration.<br>
				If the optional argument <b>indent</b> is set to some <i>positive</i> value then the returned XmlDocument
                                will be nicely formatted and properly indented by the required factor; <i>ZERO</i> will cause the whole
                                XmlDocument to be returned as a single line. (default setting is <i>negative</i> indenting, i.e. not reformatting at all).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object).</td></tr>
			<tr><td><b>XB_SchemaValidate</b></td>
				<td>XB_SchemaValidate(  xmlObject <i>XmlBLOB</i> , schemaURI <i>Text</i> [ , compressed <i>Boolean</i> ] ) : <i>XmlBLOB</i><hr>
				XB_SchemaValidate(  xmlObject <i>XmlBLOB</i> , internalSchemaURI <i>Boolean</i> [ , compressed <i>Boolean</i> ] ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Construct an XML validated XmlBLOB object starting from an XmlDocument.<ul>
				<li>If <b>compressed</b> is set to TRUE the XmlBlob object will be compressed (default setting).</li>
                                <li>If <b>schemaURI</b> is specified then the XmlDocument will be validated against the given Schema (default setting is skipping any XML validation).</li>
                                <li>If <b>internalSchemaURI</b> is set (any value), then the XmlDocument will be validated againt the Schema URI internally defined within the XmlDocument itself (if any).</li></ul><hr>
				<b>NULL</b> will be returned if the input XmlBLOB fails to pass validation for any reason.</td></tr>
			<tr><td><b>XB_Compress</b></td>
				<td>XB_Compress( xmlObject <i>XmlBLOB</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>A new compressed XmlBLOB object will be returned.<br>
                                If the input XmlBLOB is already compressed this one is a harmless no-op.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object).</td></tr>
			<tr><td><b>XB_Uncompress</b></td>
				<td>XB_Uncompress( xmlObject <i>XmlBLOB</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>A new uncompressed XmlBLOB object will be returned.<br>
                                If the input XmlBLOB is already uncompressed this one is a harmless no-op.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object).</td></tr>
			<tr><td><b>XB_IsValid</b></td>
				<td>XB_IsValid( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.</td></tr>
			<tr><td><b>XB_IsCompressed</b></td>
				<td>XB_IsCompressed( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.</td></tr>
			<tr><td><b>XB_IsSchemaValidated</b></td>
				<td>XB_IsSchemaValidated( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.</td></tr>
			<tr><td><b>XB_IsIsoMetadata</b></td>
				<td>XB_IsIsoMetadata( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.</td></tr>
			<tr><td><b>XB_IsSldSeVectorStyle</b></td>
				<td>XB_IsSldSeVectorStyle( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.</td></tr>
			<tr><td><b>XB_IsSldSeRasterStyle</b></td>
				<td>XB_IsSldSeRasterStyle( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.</td></tr>
			<tr><td><b>XB_IsSvg</b></td>
				<td>XB_IsSvg( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.</td></tr>
			<tr><td><b>XB_GetDocumentSize</b></td>
				<td>XB_GetDocumentSize( xmlObject <i>XmlBLOB</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the size in bytes of the corresponding uncompressed XmlDocument.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object).</td></tr>
			<tr><td><b>XB_GetEncoding</b></td>
				<td>XB_GetEncoding( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the character encoding internally declared by the XmlDocument corresponding to the input XmlBLOB.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when the XmlDocument doesn't explicitly declares any encoding.</td></tr>
			<tr><td><b>XB_GetSchemaURI</b></td>
				<td>XB_GetSchemaURI( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the Schema URI effectively used to validate an XmlBLOB.<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when the XmlBLOB isn't validated.</td></tr>
			<tr><td><b>XB_GetInternalSchemaURI</b></td>
				<td>XB_GetInternalSchemaURI( xmlPayload <i>BLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the Schema URI internally declared by the input XmlDocument
				(<b>xsi:noNamespeceSchemaLocation</b> or <b>xsi:schemaLocation</b>).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when the XmlDocument doesn't declares any Schema at all.</td></tr>
			<tr><td><b>XB_GetFileId</b></td>
				<td>XB_GetFileId( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the FileIdentifier defined within the XmlBLOB (if any).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when no FileIdentifier is defined.<hr>Supported only on ISO Metadata XML Documents.</td></tr>
			<tr><td><b>XB_SetFileId</b></td>
				<td>XB_SetFileId( xmlObject <i>XmlBLOB</i> , fileId <i>String</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return a new XmlBLOB by replacing the FileIdentifier value.<br>
				The input XmlBLOB is expected to be of the <u>ISO Metadata</u> type and must containt an already defined <u>FileIdentifier</u>.<hr>
				<b>NULL</b> will be returned for any invalid input.</td></tr>
			<tr><td><b>XB_AddFileId</b></td>
				<td>XB_AddFileId( xmlObject <i>XmlBLOB</i> , fileId <i>String</i> , IdNameSpacePrefix <i>String</i> , IdNameSpaceURI <i>String</i> , CsNameSpacePrefix <i>String</i> , CsNameSpaceURI <i>String</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return a new XmlBLOB by inserting a FileIdentifier value.<br>
				The input XmlBLOB is expected to be of the <u>ISO Metadata</u> type and must not containt an already defined <u>FileIdentifier</u>.<hr>
				<b>IdNameSpacePrefix</b> and <b>IdNameSpaceURI</b> are expected to represent the <u>namespace</u> (if any) corresponding to the <b>&lt;fileIdentifier&gt;</b> tag (could be eventually <b>NULL</b>).<br>
				<b>CsNameSpacePrefix</b> and <b>CsNameSpaceURI</b> are expected to represent the <u>namespace</u> (if any) corresponding to the <b>&lt;CharacterString&gt;</b> tag (could be eventually <b>NULL</b>).<hr>
				<b>NULL</b> will be returned for any invalid input.</td></tr>
			<tr><td><b>XB_GetParentId</b></td>
				<td>XB_GetParentId( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the ParentIdentifier defined within the XmlBLOB (if any).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when no ParentIdentifier is defined.<hr>Supported only on ISO Metadata XML Documents.</td></tr>
			<tr><td><b>XB_SetParentId</b></td>
				<td>XB_SetParentId( xmlObject <i>XmlBLOB</i> , parentId <i>String</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return a new XmlBLOB by replacing the ParentIdentifier value.<br>
				The input XmlBLOB is expected to be of the <u>ISO Metadata</u> type and must containt an already defined <u>ParentIdentifier</u>.<hr>
				<b>NULL</b> will be returned for any invalid input.</td></tr>
			<tr><td><b>XB_AddParentId</b></td>
				<td>XB_AddParentId( xmlObject <i>XmlBLOB</i> , parentId <i>String</i> , IdNameSpacePrefix <i>String</i> , IdNameSpaceURI <i>String</i> , CsNameSpacePrefix <i>String</i> , CsNameSpaceURI <i>String</i> ) : <i>XmlBLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return a new XmlBLOB by inserting a ParentIdentifier value.<br>
				The input XmlBLOB is expected to be of the <u>ISO Metadata</u> type and must not containt an already defined <u>ParentIdentifier</u>.<hr>
				<b>IdNameSpacePrefix</b> and <b>IdNameSpaceURI</b> are expected to represent the <u>namespace</u> (if any) corresponding to the <b>&lt;parentIdentifier&gt;</b> tag (could be eventually <b>NULL</b>).<br>
				<b>CsNameSpacePrefix</b> and <b>CsNameSpaceURI</b> are expected to represent the <u>namespace</u> (if any) corresponding to the <b>&lt;CharacterString&gt;</b> tag (could be eventually <b>NULL</b>).<hr>
				<b>NULL</b> will be returned for any invalid input.</td></tr>
			<tr><td><b>XB_GetTitle</b></td>
				<td>XB_GetTitle( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the Title defined within the XmlBLOB (if any).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when no Title is defined.<hr>Supported only on ISO Metadata and SLD/SE Styles.</td></tr>
			<tr><td><b>XB_GetAbstract</b></td>
				<td>XB_GetAbstract( xmlObject <i>XmlBLOB</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the Abstract defined within the XmlBLOB (if any).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when no Abstract is defined.<hr>Supported only on ISO Metadata and SLD/SE Styles.</td></tr>
			<tr><td><b>XB_GetGeometry</b></td>
				<td>XB_GetGeometry( xmlObject <i>XmlBLOB</i> ) : <i>Geometry</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the Geometry (Bounding Box) defined within the XmlBLOB (if any).<hr>
				<b>NULL</b> will be returned for any invalid input (not a valid XmlBLOB object), or when no Bounding Box is defined.<hr>Supported only on ISO Metadata XML Documents.</td></tr>
			<tr><td><b>XB_GetLastParseError</b></td>
				<td>XB_GetLastParseError( <i>void</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the most recent XML parsing error (if any).<hr>
				<b>NULL</b> will be returned if there is no pending parsing error.</td></tr>
			<tr><td><b>XB_GetLastValidateError</b></td>
				<td>XB_GetLastValidateError( <i>void</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the most recent XML validating error (if any).<hr>
				<b>NULL</b> will be returned if there is no pending validating error.</td></tr>
			<tr><td><b>XB_IsValidXPathExpression</b></td>
				<td>XB_IsValidXPathExpression( expr <i>Text</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>The return type is Integer, with a return value of 1 for TRUE, 0 for FALSE, and &#8211;1 for UNKNOWN
					corresponding to a function invocation on NULL arguments.</td></tr>
			<tr><td><b>XB_GetLastXPathError</b></td>
				<td>XB_GetLastXPathError( <i>void</i> ) : <i>String</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Will return the most recent XPath error (if any).<hr>
				<b>NULL</b> will be returned if there is no pending XPath error.</td></tr>
			<tr><td><b>XB_CacheFlush</b></td>
				<td>XB_CacheFlush( <i>void</i> ) : <i>Boolean</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>Reset the internal XML Schema cache to its initial empty state.</td></tr>
			<tr><td><b>XB_LoadXML</b></td>
				<td>XB_LoadXML( filepath-or-URL <i>String</i> ) : <i>BLOB</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>If <i>filepath-or-URL</i> corresponds to some valid local pathname, and the corresponding file (expected to contain a well-formed XML Document)
					can be actually accessed in read mode, then the whole file content will be returned as a
					BLOB value.<br>
					This function is even able to acces a remote XML Document identified by an <b>URL</b>.<br>
					Otherwise NULL will be returned.<br>
					<u>Please note:</u> SQLite doesn't support BLOB values bigger than SQLITE_MAX_LENGTH (usually, 1 GB).<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.<br>
					Please see: <b>CountUnsafeTriggers()</b></td></tr>
			<tr><td><b>XB_StoreXML</b></td>
				<td>XB_StoreXML( XmlObject <i>XmlBLOB</i> , filepath <i>String</i> ) : <i>Integer</i><hr>
				XB_StoreXML( XmlObject <i>XmlBLOB</i> , filepath <i>String</i> , indent <i>Integer</i> ) : <i>Integer</i></td>
				<td></td>
				<td align="center" bgcolor="#99d099">libxml2</td>
				<td>If <i>XmlObject</i> is of the XmlBLOB-type, and if <i>filepath</i> corresponds to some valid pathname 
					(accessible in write/create mode), then the corresponding file will be created/overwritten so to
					contain the corresponding XML Document (fully preserving the original character encoding).<br>
				If the optional argument <b>indent</b> is set to some <i>positive</i> value then the returned XmlDocument
                                will be nicely formatted and properly indented by the required factor; <i>ZERO</i> will cause the whole 
                                XmlDocument to be returned as a single line. (default setting is <i>negative</i> indenting, i.e. not reformatting at all).<hr>
					The return type is Integer, with a return value of 1 for success, 0 for failure and -1 for invalid arguments.<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.<br>
					Please see: <b>CountUnsafeTriggers()</b></td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="srid">SQL functions supporting SRID inspection</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0" colspan="3">Summary</th></tr>
			<tr><td><b>SridIsGeographic</b></td>
				<td>SridIsGeographic( SRID <i>Integer</i> ) : <i>Integer</i></td>
				<td colspan="3">Will inspect the SRID definitions checking if the SRID is of the <b>Geographic</b> type;<br>
					will return <b>1</b> (i.e. <b>TRUE</b>) or <b>0</b> (i.e. <b>FALSE</b>).<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridIsProjected</b></td>
				<td>SridIsProjected( SRID <i>Integer</i> ) : <i>Integer</i></td>
				<td colspan="3">Will inspect the SRID definitions checking if the SRID is of the <b>Projected</b> type;<br>
					will return <b>1</b> (i.e. <b>TRUE</b>) or <b>0</b> (i.e. <b>FALSE</b>).<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridHasFlippedAxes</b></td>
				<td>SridHasFlippedAxes( SRID <i>Integer</i> ) : <i>Integer</i></td>
				<td colspan="3">Will inspect the SRID definitions checking if the SRID requires a flipped Axes configuration: i.e. <b>Y,X</b> instead of the most usual <b>X,Y</b>;<br>
					will return <b>1</b> (i.e. <b>TRUE</b>) or <b>0</b> (i.e. <b>FALSE</b>).<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetSpheroid</b></td>
				<td>SridGetSpheroid( SRID <i>Integer</i> ) : <i>Text</i><hr>
					SridGetEllipsoid( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Spheroid</b> name.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetPrimeMeridian</b></td>
				<td>SridGetPrimeMeridian( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Prime Meridian</b> name.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetDatum</b></td>
				<td>SridGetDatum( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Datum</b> name.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetUnit</b></td>
				<td>SridGetUnit( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Unit</b> name.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetProjection</b></td>
				<td>SridGetProjection( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Projection</b> name.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetAxis_1_Name</b></td>
				<td>SridGetAxis_1_Name( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Name</b> for its <b>first</b> axis.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetAxis_1_Orientation</b></td>
				<td>SridGetAxis_1_Orientation( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Orientation</b> for its <b>first</b> axis.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetAxis_2_Name</b></td>
				<td>SridGetAxis_2_Name( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Name</b> for its <b>second</b> axis.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td><b>SridGetAxis_2_Orientation</b></td>
				<td>SridGetAxis_2_Orientation( SRID <i>Integer</i> ) : <i>Text</i></td>
				<td colspan="3">Will inspect the SRID definitions then returning the appropriate <b>Orientation</b> for its <b>second</b> axis.<br>
					<b>NULL</b> will be returned on invalid argument or if the SRID is undefined.</td></tr>
			<tr><td colspan="5" align="center" bgcolor="#f0e0c0">
				<h3><a name="advanced">miscellaneous advanced SQL functions</a></h3></td></tr>
			<tr><th bgcolor="#d0d0d0">Function</th>
				<th bgcolor="#d0d0d0">Syntax</th>
				<th bgcolor="#d0d0d0" colspan="3">Summary</th></tr>
			<tr><td><b>CloneTable</b></td>
				<td>CloneTable( db-prefix <i>Text</i> , input_table <i>Text</i> , output_table <i>Text</i> , 
				transaction <i>Integer</i> ) : <i>Integer</i><hr>
				CloneTable(  db-prefix <i>Text</i> , input_table <i>Text</i> , output_table <i>Text</i> , 
				transaction <i>Integer</i> , option_1 <i>Text</i> [ , ... , option_10 <i>Text</i> ] ) : <i>Integer</i></td>
				<td colspan="3">Will clone (i.e. create+copy) an origin table into a destination table: 
				the origin could be eventually located into some <i>attached</i> DB, but the destination is always
				assumed to be located into the primary DB</b>.<ul>
				<li>Mandatory arguments:
				<ul>
					<li><b>db-prefix</b> corresponding to the origin; the primary DB always corresponds to the <i>main</i> prefix.</li>
					<li><b>input_table</b> name of the origin table</li>
					<li><b>output_table</b> name of the destination table</li>
					<li><b>transaction</b> a <i>boolean</i> values stating if the whole operation has to be atomically confined
					within a monolithic SQL transaction</li>
				</ul></li>
				<li>Optional arguments: a maximum of 10 further options could be eventually specified. Valid options are:
				<ul>
					<li><b>::with-foreign-keys::</b></li>
					<li><b>::with-triggers::</b></li>
					<li><b>::resequence::</b></li>
					<li><b>::append::</b></li>
					<li><b>::ignore::</b><i>column_name</i></li>
					<li><b>::cast2multi::</b><i>geometry_column</i></li>
				</ul></li>
				</ul>
				<hr>
				Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success. <b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>CheckDuplicateRows</b></td>
				<td>CheckDuplicateRows( table <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Will check if the given <b>table</b> does contain duplicate rows, i.e. rows presenting identical 
				values for all columns (ignoring any Primary Key column).
				<hr>
				Will return the total number of duplicate rows found.<br> <b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>RemoveDuplicateRows</b></td>
				<td>RemoveDuplicateRows( table <i>Text</i> ) : <i>Integer</i><hr>
				RemoveDuplicateRows( table <i>Text</i> , transaction <i>Boolean</i> ) : <i>Integer</i></td>
				<td colspan="3">Will remove all duplicate rows from the given <b>table</b> preserving only a songle occurrence.<br>
				The <i>optional</i> argument <b>transaction</b> determines if an internal SQL Transaction should be automatically
				started or not (the default setting if not explicitly overridden is <b>TRUE</b>).
				<hr>
				Will return the total number of deleted rows.<br> <b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>ElementaryGeometries</b></td>
				<td>ElementaryGeometries( in_table <i>Text</i> , geom_column <i>Text</i> , out_table <i>Text</i> ,
				out_pk <i>Text</i> , out_multi_id <i>Text</i> ) : <i>Integer</i><hr>
				ElementaryGeometries( in_table <i>Text</i> , geom_column <i>Text</i> , out_table <i>Text</i> ,
				out_pk <i>Text</i> , out_multi_id <i>Text</i> , transaction <i>Boolean</i> ) : <i>Integer</i></td>
				<td colspan="3">Will create a new <b>out_table</b> directly corresponding to <b>in_table</b>.
				The output table will be arranged in such a way that each row will always contain an elementary Geometry;
				so each time that a <b>MULTI-type</b> Geometry is found in the input table it will be split into mamy
				distinct rows.<br>
				<b>out_pk</b> is the name to be set for the output Primary Key, and <b>out_multi_id</b> is the name to
				be set for a second column within the output table where to store the original Primary Key.<br>
				The <i>optional</i> argument <b>transaction</b> determines if an internal SQL Transaction should be automatically
				started or not (the default setting if not explicitly overridden is <b>TRUE</b>).
				<hr>
				Will return the total number of rows inserted into the output table.<br> <b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>DropGeoTable</b></td>
				<td>DropGeoTable( table <i>Text</i> ) : <i>Integer</i><hr>
				DropGeoTable( table <i>Text</i> , transaction <i>Boolean</i> ) : <i>Integer</i><hr>
				DropGeoTable( db-prefix <i>Text</i> , table <i>Text</i> ) : <i>Integer</i><hr>
				DropGeoTable( db-prefix <i>Text</i> , table <i>Text</i> , transaction <i>Boolean</i> ) : <i>Integer</i></td>
				<td colspan="3">Will completely remove a Geometry Table (or Spatial View) this including any eventual SpatialIndex,
				metadata and statistics definitions an alike.<br>
				The <i>optional</i> argument <b>transaction</b> determines if an internal SQL Transaction should be automatically
				started or not (the default setting if not explicitly overridden is <b>TRUE</b>).
				<hr>
				Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success..<br> 
				<b>NULL</b> will be returned on invalid arguments.</td></tr>
			<tr><td><b>ImportSHP</b></td>
				<td>ImportSHP( filename <i>Text</i> , table <i>Text</i> , charset <i>Text</i> ) : <i>Integer</i><hr>
				ImportSHP( filename <i>Text</i> , table <i>Text</i> , charset <i>Text</i> [ , srid <i>Integer</i>  [ ,
				    geom_column <i>Text</i> [ , pk_column <i>Text</i> [ , geometry_type <i>Text</i> [ , coerce2D <i>Integer</i> 
				    [ , compressed <i>Integer</i> [ , spatial_index <i>Integer</i> [ , text_dats <i>Integer</i> ] ] ] ] ] ] ] ] )
				    : <i>Integer</i></td>
				<td colspan="3">Will import an external Shapfile into an internal Table:
				<ul>
				<li>Mandatory arguments:
				<ul>
					<li><b>filename</b> absolute or relative path leading to the Shapefile (omitting any <i>.shp</i>, <i>.shx</i> or <i>.dbf</i> suffix).</li>
					<li><b>table</b> name of the table to be created.</li>
					<li><b>charset</b> the character encoding adopted by the DBF member, as e.g. <i>UTF-8</i> or <i>CP1252</i></li>
				</ul></li>
				<li>Optional arguments:
				<ul>
					<li><b>srid</b> EPSG SRID value; <i>-1</i> by default.</li>
					<li><b>geom_column</b> name to assigned to the Geometry column; <i>Geometry</i> by default.</li>
					<li><b>pk_column</b> name of a DBF column to be used in the Primary Key role; an <i>INTEGER AUTOINCREMENT</i> 
					PK will be created by default.</li>
					<li><b>geometry_type</b> one between: <i>AUTO</i>, <i>POINT|Z|M|ZM</i>, <i>LINESTRING|Z|M|ZM</i>,
						<i>POLYGON|Z|M|ZM</i>, <i>MULTIPOINT|Z|M|ZM</i>, <i>LINESTRING|Z|M|ZM</i>, <i>MULTIPOLYGON|Z|M|ZM</i>;
						 by default <i>AUTO</i>.</li>
					<li><b>coerce2D</b> boolean flag: casting to 2D or not; <i>0</i> by default.</li>
					<li><b>compressed</b> boolean flag; compressed geometries or not; <i>0</i> by default.</li>
					<li><b>spatial_index</b> boolean flag: immediately building a Spatial Index or not; <i>0</i> by default.</li>
					<li><b>text_dates</b> boolean flag: interpreting DBF dates as plaintext or not: <i>0</i> by default
					(i.e. as <i>Julian Day</i>).</li>
				</ul></li>
				</ul>
				<hr>
				Will return the total number of imported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ExportSHP</b></td>
				<td>ExportSHP( table <i>Text</i> , geom_column <i>Text</i> , filename <i>Text</i> , charset <i>Text</i> ) : <i>Integer</i><hr>
				ExportSHP( table <i>Text</i> , geom_column <i>Text</i> , filename <i>Text</i> , charset <i>Text</i> , geom_type <i>Text</i>) : <i>Integer</i></td>
				<td colspan="3">Will export an internal Table as an external Shapefile:
				<ul>
					<li><b>table</b> name of the table to be exported.</li>
					<li><b>geom_column</b> name of the Geometry column.</li>
					<li><b>filename</b> absolute or relative path leading to the Shapefile (omitting any <i>.shp</i>, <i>.shx</i> or <i>.dbf</i> suffix).</li>
					<li><b>charset</b> the character encoding adopted by the DBF member, as e.g. <i>UTF-8</i> or <i>CP1252</i></li>
					<li>the optional argument <b>geom_type</b> is useful when exporting unregistered Geometries, and
					can be one between: <i>POINT</i>, <i>LINESTRING</i>, <i>POLYGON</i> or <i>MULTUPOINT</i>.</li>
				</ul>
				<hr>
				Will return the total number of exported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ImportDBF</b></td>
				<td>ImportDBF( filename <i>Text</i> , table <i>Text</i> , charset <i>Text</i> ) : <i>Integer</i><hr>
				ImportDBF( filename <i>Text</i> , table <i>Text</i> , charset <i>Text</i> [ , pk_column <i>Text</i>  
				    [ , text_dats <i>Integer</i> ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will import an external DBF file into an internal Table:
				<ul>
				<li>Mandatory arguments:
				<ul>
					<li><b>filename</b> absolute or relative path leading to the DBF (including the <i>.dbf</i> suffix).</li>
					<li><b>table</b> name of the table to be created.</li>
					<li><b>charset</b> the character encoding adopted by the DBF, as e.g. <i>UTF-8</i> or <i>CP1252</i></li>
				</ul></li>
				<li>Optional arguments:
				<ul>
					<li><b>pk_column</b> name of a DBF column to be used in the Primary Key role; an <i>INTEGER AUTOINCREMENT</i> 
					PK will be created by default.</li>
					<li><b>text_dates</b> boolean flag: interpreting DBF dates as plaintext or not: <i>0</i> by default
					(i.e. as <i>Julian Day</i>).</li>
				</ul></li>
				</ul>
				<hr>
				Will return the total number of imported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ExportDBF</b></td>
				<td>ExportDBF( table <i>Text</i> , filename <i>Text</i> , charset <i>Text</i> ) : <i>Integer</i></td>
				<td colspan="3">Will export an internal Table as an external DBF file:
				<ul>
					<li><b>table</b> name of the table to be exported.</li>
					<li><b>filename</b> absolute or relative path leading to the DBF (including the <i>.dbf</i> suffix).</li>
					<li><b>charset</b> the character encoding adopted by the DBF, as e.g. <i>UTF-8</i> or <i>CP1252</i></li>
				</ul>
				<hr>
				Will return the total number of exported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ExportKML</b></td>
				<td>ExportKML( table <i>Text</i> , geo_column <i>Text</i> , filename <i>Text</i> ) : <i>Integer</i><hr>
				ExportKML( table <i>Text</i> , geo_column <i>Text</i> , filename <i>Text</i> [ , precision <i>Integer</i>
				[ , name_column <i>Text</i> [ , description <i>Text</i> ] ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will export an internal Table as an external KML file:
				<ul>
					<li>Mandatory aguments:
					<ul>
						<li><b>table</b> name of the table to be exported.</li>
						<li><b>geom_column</b> name of the Geometry column.</li>
						<li><b>filename</b> absolute or relative path leading to the KML file.</li>
					</ul></li>
					<li>Optional aguments:
					<ul>
						<li><b>precision</b> number of decimal digits to be exported; <i>8</i> by default.</li>
						<li><b>name_column</b> name of the table's column containing KML names.</li>
						<li><b>description_column</b> name of the table's column containing KML descriptions.</li>
					</ul></li>
				</ul>
				<hr>
				Will return the total number of exported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ExportGeoJSON</b></td>
				<td>ExportGeoJSON( table <i>Text</i> , geo_column <i>Text</i> , filename <i>Text</i> ) : <i>Integer</i><hr>
				ExportGeoJSON( table <i>Text</i> , geo_column <i>Text</i> , filename <i>Text</i> [ , format <i>Text</i>
				[ , precision <i>Integer</i> ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will export an internal Table as an external GeoJSON file:
				<ul>
					<li>Mandatory aguments:
					<ul>
						<li><b>table</b> name of the table to be exported.</li>
						<li><b>geom_column</b> name of the Geometry column.</li>
						<li><b>filename</b> absolute or relative path leading to the GeoJSON file.</li>
					</ul></li>
					<li>Optional aguments:
					<ul>
						<li><b>format</b> specifies one of the several alternative GeoJSON formats; allowed values are
						<i>none</i>, <i>MBR</i>, <i>withShortCRS</i>, <i>MBRwithShortCRS</i>, <i>withLongCRS</i>
						or <i>MBRwithLongCRS</i>.</li>
						<li><b>precision</b> number of decimal digits to be exported; <i>8</i> by default.</li>
					</ul></li>
				</ul>
				<hr>
				Will return the total number of exported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ImportXLS</b></td>
				<td>ImportXLS( filename <i>Text</i> , table <i>Text</i> ) : <i>Integer</i><hr>
				ImportXLS( filename <i>Text</i> , table <i>Text</i> [ , worksheet_index <i>Integer</i>  
				    [ , first_line_titles <i>Integer</i> ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will import an external spreadsheet file (<i>Microsoft .xls format</i>) into an internal Table:
				<ul>
				<li>Mandatory arguments:
				<ul>
					<li><b>filename</b> absolute or relative path leading to the spreadsheet file.</li>
					<li><b>table</b> name of the table to be created.</li>
				</ul></li>
				<li>Optional arguments:
				<ul>
					<li><b>worksheet_index</b> a positive integer selecting the target worksheet in the case of a multi-sheet: <i>0</i> by default..</li>
					<li><b>first_line_titles</b> boolean flag: the first line of the worksheet contains column names or not: <i>0</i> by default.</li>
				</ul></li>
				</ul>
				<hr>
				Will return the total number of imported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ImportWFS</b></td>
				<td>ImportWFS( filename_or_url <i>Text</i> , layer_name <i>Text</i> , table <i>Text</i> ) : <i>Integer</i><hr>
				ImportXLS( filename_or_url <i>Text</i> , layer_name <i>Text</i> , table <i>Text</i> [ , pk_column <i>Text</i>  
				    [ , swap_axes <i>Integer</i> [ , page_size <i>Integer</i> [ , spatial_index <i>Integer</i> ] ] ] ] ) : <i>Integer</i></td>
				<td colspan="3">Will import data from a WFS datasource:
				<ul>
				<li>Mandatory arguments:
				<ul>
					<li><b>filename_or_url</b> absolute or relative path leading to the WFS file.<br>
					Alternatively an URL corresponding to a WFS service.</li>
					<li><b>layer_name</b> name of the WFS layer.</li>
					<li><b>table</b> name of the table to be created.</li>
				</ul></li>
				<li>Optional arguments:
				<ul>
					<li><b>pk_column</b> name of a WFS column to be used in the Primary Key role; an <i>INTEGER AUTOINCREMENT</i> 
					PK will be created by default.</li>
					<li><b>swap_axes</b> boolean flag: swapping the <i>X</i> and <i>Y</i> axes or not: <i>0</i> by default.</li>
					<li><b>page_size</b> : how many features for each WFS paged requests; a <i>negative</i> number or <i>zero</i> if
					you don't intend to activate WFS paging. <i>-1</i> by default.</li>
					<li><b>spatial_index</b> boolean flag: immediately building a Spatial Index or not; <i>0</i> by default.</li>
				</ul></li>
				</ul>
				<hr>
				Will return the total number of imported rows.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ImportDXF</b></td>
				<td>ImportDXF( filename <i>String</i> ) : <i>Integer</i><hr>
					ImportDXF( filename <i>String</i> [ , srid <i>Integer</i>, append <i>Integer</i>, dimensions <i>Text</i>,
					mode <i>Text</i> , special_rings <i>Text</i> , table_prefix <i>Text</i> , layer_name <i>Text</i> ] ) : <i>Integer</i></td>
				<td colspan="3">Will import an external DXF file.<ul>
                    <li><b>filename</b> absolute or relative path leading to the DXF file.</li>
					<li><b>srid</b> EPSG SRID value; <i>-1</i> by default.</li>
					<li><b>append</b> boolean flag: enabling or not <i>append mode</i>: <i>0</i> by default.</li>
					<li><b>dimensions</b> one between <i>AUTO</i>, <i>2D</i> or <i>3D</i>.</li>
					<li><b>mode</b> one between <i>DISTINCT</i> or <i>MIXED</i>.</li>
					<li><b>special_rings</b> one between <i>NONE</i>, <i>LINKED</i> or <i>UNLINKED</i>.</li>
					<li><b>table_prefix</b>: a prefix for table names; <i>NULL</i> if no prefix is required.</li>
					<li><b>layer_name</b>: name of a single DXF layer to be imported: <i>NULL</i> will import all layers found.</li>
					</ul>
					Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>
			<tr><td><b>ImportDXFfromDir</b></td>
				<td>ImportDXFfromDir( dir_path <i>String</i> ) : <i>Integer</i><hr>
					ImportDXFfromDir( dir_path <i>String</i> [ , srid <i>Integer</i>, append <i>Integer</i>, dimensions <i>Text</i>,
					mode <i>Text</i> , special_rings <i>Text</i> , table_prefix <i>Text</i> , layer_name <i>Text</i> ] ) : <i>Integer</i></td>
				<td colspan="3">Will import all DXF files found within a given Directory.<ul>
                    <li><b>dir_path</b> absolute or relative path leading to a directory containing all the <i>*.dxf</i> files to be imported.</li>
					<li><b>srid</b> EPSG SRID value; <i>-1</i> by default.</li>
					<li><b>append</b> boolean flag: enabling or not <i>append mode</i>: <i>0</i> by default.</li>
					<li><b>dimensions</b> one between <i>AUTO</i>, <i>2D</i> or <i>3D</i>.</li>
					<li><b>mode</b> one between <i>DISTINCT</i> or <i>MIXED</i>.</li>
					<li><b>special_rings</b> one between <i>NONE</i>, <i>LINKED</i> or <i>UNLINKED</i>.</li>
					<li><b>table_prefix</b>: a prefix for table names; <i>NULL</i> if no prefix is required.</li>
					<li><b>layer_name</b>: name of a single DXF layer to be imported: <i>NULL</i> will import all layers found.</li>
					</ul>
					Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success.<br> <b>NULL</b> will be returned on invalid arguments.<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>		
			<tr><td><b>ExportDXF</b></td>
				<td>ExportDXF( out_dir <i>String</i> , filename <i>String</i> , sql_query <i>String</i> , layer_col_name <i>String</i> , 
                geom_col_name <i>String</i> , label_col_name <i>String</i> , text_height_col_name <i>String</i> , 
                text_rotation_col_name <i>String</i> , geom_filter <i>Geometry</i> [ , precision <i>Integer</i> ] ) : <i>Integer</i></td>
				<td colspan="3">Will export a whole DXF file.<ul>
                    <li>The output file path is controlled by <b>out_dir</b> and <b>filename</b>.</li>
					<li><b>sql_query</b> is a complete SQL Statement returning the dataset to be exported.</li>
					<li><b>layer_col_name</b>, <b>geom_col_name</b>, <b>label_col_name</b>, <b>text_height_col_name</b> 
					and <b>text_rotation_col_name</b> must specify the corresponding <u>column names</u> within the resultset
					returned by <b>sql_query</b> (<i>label_col_name</i>, <i>text_height_col_name</i> and <i>text_rotation_col_name</i> could be eventually <b>NULL</b>).</li>
					<li><b>geom_filter</b> acts as a <u>spatial filter</u> selecting which entities have to be exported (could be <b>NULL</b>).</li>
					<li>the optional argument <b>precision</b> specificies how many <u>decimal digits</u> are required for coordinate values: if not specified the default is <b>3</b>.</li>
					</ul>
					Will return <b>0</b> (i.e. <b>FALSE</b>) on failure, any other value (i.e. <b>TRUE</b>) on success.<hr>
                    <u>Please note well</u>: this SQL function open the doors to many potential security issues, and thus is always <i>disabled by default</i>.<br>
                    Explicitly setting the environment variable <b>SPATIALITE_SECURITY=relaxed</b> is absolutely required in order to effectively enable this function.</td></tr>	
		</tbody></table>
		<a href="https://www.gaia-gis.it/fossil/libspatialite">back</a>
	</body></html>
